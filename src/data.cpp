#include "data.h"

const std::string autogenerated_warning = "/* DO NOT EDIT! This is an autogenerated file. */\n\n";
const std::string autogenerated_warning_h = autogenerated_warning + "#pragma once\n\n";

const string space = "    ";
const string String = "String";
const string TextType = "Text";
const string storageImpl = "StorageImpl";
const string anyTable = "AnyTable";
const string anyType = "Any";

const map<string, string> objectNames = 
{
    { "Players", "to_string(mechanoid)" },
    { "ScriptVariables", "variable" },
    { "ClanReputations", "clan.id < clan2.id ? (to_string(clan).wstring() + L\" - \" + to_string(clan2).wstring()) : (to_string(clan2).wstring() + L\" - \" + to_string(clan).wstring())" },
    { "MapBuildings", "to_string(building)" },
    { "Coordinates", "to_string(*this)" },
    { "QuestRewards", "to_string(quest)" },
    { "Maps", "text_id" },
};

string splitWords(string s)
{
    string r;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (isupper(s[i]) && i)
            r += " ";
        r += s[i];
    }
    return r;
}

string tr(string s)
{
    return "QCoreApplication::translate(\"DB\", \"" + s + "\")";
}

string inheritQObject()
{
    string s;
    //s += "#ifdef USE_QT\n";
    //s += space + ": public QObject\n";
    //s += "#endif\n";
    return s;
}

string declareQObject()
{
    string s;
    //s += "#ifdef USE_QT\n";
    //s += space + "Q_OBJECT\n";
    //s += "#endif\n\n";
    //s += "public:\n";
    return s;
}

template<typename T, typename K>
set<T> mapToSet(const map<K, T> &map)
{
    set<T> s;
    for (auto &v : map)
        s.insert(v.second);
    return s;
}

string Column::printVar() const
{
    string s;
    if (fk)
    {
        s += "IdPtr<" + fk->table->getCppName() + "> " + printVarName();
    }
    else
    {
        switch (type)
        {
        case ColumnType::Integer:
            s += "int";
            break;
        case ColumnType::Real:
            s += "float";
            break;
        case ColumnType::Text:
            s += TextType;
            break;
        }
        s += " " + printVarName();
        if (type == ColumnType::Integer || type == ColumnType::Real)
        {
            s += " = ";
            switch (type)
            {
            case ColumnType::Integer:
                s += defaultValue.empty() ? "0" : defaultValue;
                break;
            case ColumnType::Real:
                s += defaultValue.empty() ? "0.0f" : defaultValue;
                break;
            case ColumnType::Text:
                s += defaultValue;
                break;
            }
        }
    }
    return s;
}

string Column::printVarName() const
{
    string s;
    if (fk)
    {
        s += getCleanName();
    }
    else
    {
        s += name;
    }
    return s;
}

string Column::printLoad() const
{
    string s;
    if (fk)
    {
        s += getCleanName() + ".id = std::stoi(cols[" + to_string(id) + "])";
    }
    else
    {
        s += name + " = ";
        switch (type)
        {
        case ColumnType::Integer:
            s += "std::stoi(cols[" + to_string(id) + "])";
            break;
        case ColumnType::Real:
            s += "std::stof(cols[" + to_string(id) + "])";
            break;
        case ColumnType::Text:
            s += "cols[" + to_string(id) + "]";
            break;
        }
    }
    return s;
}

string Column::printSet() const
{
    string s;
    if (fk)
    {
        s += getCleanName() + ".id = std::stoi(text.string())";
    }
    else
    {
        s += name + " = ";
        switch (type)
        {
        case ColumnType::Integer:
            s += "std::stoi(text.string())";
            break;
        case ColumnType::Real:
            s += "std::stof(text.string())";
            break;
        case ColumnType::Text:
            s += "text.string()";
            break;
        }
    }
    return s;
}

string Column::printSetPtr() const
{
    string s;
    if (fk)
    {
        s += getCleanName() + " = std::static_pointer_cast<" + fk->table->getCppName() + ">(ptr)";
    }
    return s;
}

string Column::printSave(string var) const
{
    string s;
    if (fk)
    {
        s += "std::to_string(" + var + "->" + removeId(name) + ".id)";
    }
    else
    {
        switch (type)
        {
        case ColumnType::Integer:
        case ColumnType::Real:
            s += "std::to_string(" + var + "->" + name + ")";
            break;
        case ColumnType::Text:
            s += var + "->" + name + ".string()";
            break;
        }
    }
    return s;
}

string Table::printForward() const
{
    string s;
    s += "class " + getCppName() + ";\n";
    return s;
}

string Table::getParentName() const
{
    string p = splitWords(getCppName());
    int pos = p.rfind(' ');
    if (pos == -1)
        return "";
    p = p.substr(0, pos);
    replaceAll(p, " ", "");
    return p;
}

bool Table::isVisibleInTreeView() const 
{
    return
        !hasParent &&
        name != "Tables" &&
        1;
}

void Table::init(Tables &tables)
{
    auto tbls = tables;
    const auto pn = getParentName();
    hasParent = !pn.empty() && find_if(tables.begin(), tables.end(), [&](const decltype(tbls)::value_type &v){ return v.second.getCppName() == pn; }) != tables.end();
    hasChild = !pn.empty() && find_if(tables.begin(), tables.end(), [&](const decltype(tbls)::value_type &v){ return v.second.getCppName() == getChildName(pn); }) != tables.end();
    hasIdField = find_if(columns.begin(), columns.end(), [](const decltype(columns)::value_type &v){ return v.second.isId(); }) != columns.end();
    isMapTable = hasParent && hasChild && hasIdField;
    isProxy = !hasIdField && hasParent && hasChild;

    // assign fks
    for (auto &fk : fks)
    {
        auto &table = tables[fk.second.table_name];
        fk.second.table = &table;
        fk.second.column = &table.columns[fk.second.column_name];
        columns[fk.first].setFk(&fk.second);
        table.linksToThisTable.insert(name);
    }

    // check if container
    for (auto &table : tables)
    {
        auto &t = table.second;
        if (t.getParentName() == getCppName())
        {
            container = true;
            contains.push_back(&t);
        }
    }

    if (name == "Tables")
    {
        string s;
        s += "insert into \"Tables\" (\"text_id\") values\n";
        for (auto &table : tables)
            s += "(\"" + table.second.getName() + "\"),\n";
        s += "(\"" + anyTable + "\"),\n";
        s.resize(s.size() - 2);
        s += ";";
        sql += "\n" + s;
    }
}

string Table::print(const Tables &tables, string &si) const
{
    string s;
    string cppname = getCppName();
    set<Column> cols = mapToSet(columns);

    // localization types
    if (cppname == String)
    {
        s += "enum class LocalizationType : EnumType\n";
        s += "{\n";
        auto iter = cols.begin();
        while (iter->getName() != "ru")
            iter = next(iter);
        for (auto i = iter; i != cols.end(); i++)
            s += space + i->getName() + ",\n";
        s += "\n";
        s += space + "max\n";
        s += "};\n\n";
    }

    // class
    s += "class " + cppname + " : public IObject\n";
    s += "{\n";
    s += declareQObject();
    s += (hasIdField ? "private" : "public") + string(":\n");
    for (auto &col : cols)
    {
        s += space + col.printVar() + ";\n";
        if (col.isId())
            s += "public" + string(":\n");
    }

    // containers
    if (container)
        s += "\n";
    for (auto &t : contains)
        s += space + "CVector<Ptr<" + t->getCppName() + ">> " + t->getChildVariableArrayName(getCppName()) + ";\n";
    s += "\n";
    
    // getId(), setId()
    if (hasIdField)
    {
        s += space + "int getId() const;\n";
        si += "int " + getCppName() + "::getId() const\n";
        si += "{\n";
        si += space + "return id;\n";
        si += "}\n\n";

        s += space + "void setId(int id);\n";
        si += "void " + getCppName() + "::setId(int id)\n";
        si += "{\n";
        si += space + "this->id = id;\n";
        si += "}\n\n";

        s += "\n";
    }

    // getType()
    s += space + "virtual EObjectType getType() const;\n";
    si += "EObjectType " + getCppName() + "::getType() const\n";
    si += "{\n";
    si += space + "return EObjectType::" + getCppName() + ";\n";
    si += "}\n\n";
    
    // getVariableString()
    s += space + "virtual Text getVariableString(int columnId) const;\n";
    si += "Text " + getCppName() + "::getVariableString(int columnId) const\n";
    si += "{\n";
    {
        si += space + "switch (columnId)\n";
        si += space + "{\n";
        auto cols = mapToSet(columns);
        for (auto &col : cols)
        {
            si += space + "case " + to_string(col.getId()) + ":\n";
            si += space + ::space + "return to_string(" + col.printVarName() + ");\n";
        }
        si += space + "default:\n";
        si += space + ::space + "return \"\";\n";
        si += space + "}\n";
        si += space + "return \"\";\n";
    }
    si += "}\n\n";

    // setVariableString()
    s += space + "virtual void setVariableString(int columnId, Text text, Ptr<IObject> ptr = Ptr<IObject>());\n";
    si += "void " + getCppName() + "::setVariableString(int columnId, Text text, Ptr<IObject> ptr)\n";
    si += "{\n";
    {
        si += space + "switch (columnId)\n";
        si += space + "{\n";
        auto cols = mapToSet(columns);
        for (auto &col : cols)
        {
            si += space + "case " + to_string(col.getId()) + ":\n";
            if (col.getFk())
                si += space + ::space + col.printSetPtr() + ";\n";
            else
                si += space + ::space + col.printSet() + ";\n";
            si += space + ::space + "break;\n";
        }
        si += space + "default:\n";
        si += space + ::space + "break;\n";
        si += space + "}\n";
    }
    si += "}\n\n";
    
    // printQtTreeView()
    s += "#ifdef USE_QT\n";
    s += space + "virtual QTreeWidgetItem *printQtTreeView(QTreeWidgetItem *parent) const;\n";
    s += "#endif\n";
    si += "#ifdef USE_QT\n";
    si += "QTreeWidgetItem *" + getCppName() + "::printQtTreeView(QTreeWidgetItem *parent) const\n";
    si += "{\n";
    {
        si += space + "auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));" + "\n";
        si += space + "item->setData(0, Qt::UserRole, (uint64_t)this);" + "\n";        
        if (container)
        {
            si += "\n";
            si += space + "QTreeWidgetItem *root;\n";
            for (auto &t : contains)
            {
                si += "\n";
                string var = t->getChildArrayName(getCppName());
                si += space + "root = new QTreeWidgetItem(item, QStringList(" + tr(splitWords(var)) + "));\n";
                si += space + "root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::" + t->getCppName() + "));" + "\n";
                si += space + "for (auto &" + t->getChildVariableName(getCppName()) + " : " + t->getChildVariableArrayName(getCppName()) + ")\n";
                {
                    string space = ::space + ::space;
                    si += space + t->getChildVariableName(getCppName()) + "->" + "printQtTreeView(root);\n";
                }
            }
            si += "\n";
        }
        si += space + "item->sortChildren(0, Qt::AscendingOrder);\n";
        si += space + "return item;\n";
    }
    si += "}\n";
    si += "#endif\n\n";

    // getName()
    if (getCppName() != String)
    {
        const Column *c = 0;

        s += space + "virtual Text getName() const;\n";
        si += "Text " + getCppName() + "::getName() const\n";
        si += "{\n";
        si += space + "Text n;\n";

        // predefined name
        auto iter_object_name = objectNames.find(this->name);
        if (iter_object_name != objectNames.end())
        {
            si += space + "n = " + iter_object_name->second + ";\n";
            si += space + "if (!n.empty())\n";
            si += space + space + "return n;\n";
        }

        // name from String
        if (c = getNameColumn())
        {
            if (c->getType() == ColumnType::Text)
                si += space + "n = " + c->printVarName() + ";\n";
            else
                si += space + "n = to_string(" + c->printVarName() + ");\n";
            si += space + "if (!n.empty())\n";
            si += space + space + "return n;\n";
        }

        // name from Text
        if (c = getTextColumn())
        {
            if (c->getType() == ColumnType::Text)
                si += space + "n = " + c->printVarName() + ";\n";
            else
                si += space + "n = to_string(" + c->printVarName() + ");\n";
            si += space + "if (!n.empty())\n";
            si += space + space + "return n;\n";
        }

        // name from parent
        if (isProxy)
        {
            string var = getChildVariableName(getParentName());
            si += space + "n = to_string(" + var + ");\n";
            si += space + "if (!n.empty())\n";
            si += space + space + "return n;\n";
        }

        si += space + "return IObject::getName();\n";
        si += "}\n\n";
    }
    else
    {
        s += space + "virtual Text getName() const;\n";
        si += "Text " + getCppName() + "::getName() const\n";
        si += "{\n";
        auto iter = cols.begin();
        while (iter->getName() != "ru")
            iter = next(iter);
        si += space + "auto s = ((Text *)&" + iter->getName() + ")[gCurrentLocalizationId];" + "\n";
        si += space + "if (!s.empty())" + "\n";
        si += space + space + "return s;\n";
        si += space + "s = text_id;\n";
        si += space + "if (!s.empty())" + "\n";
        si += space + space + "return s;\n";
        si += space + "for (int i = 0; i < static_cast<int>(LocalizationType::max); i++)" + "\n";
        si += space + "{" + "\n";
        {
            string space = ::space + ::space;
            si += space + "s = ((Text *)&" + iter->getName() + ")[i];" + "\n";
            si += space + "if (!s.empty())" + "\n";
            si += space + ::space + "return s;" + "\n";
        }
        si += space + "}" + "\n";
        si += space + "return s;\n";
        si += "}\n\n";
    }
    s += "\n";

    // operator==()
    s += space + "bool operator==(const " + getCppName() + " &rhs) const;\n";
    si += "bool " + getCppName() + "::operator==(const " + getCppName() + " &rhs) const\n";
    si += "{\n";
    si += space + "return\n";
    for (auto &col : columns)
        if (col.first != "id")
            si += space + space + col.second.printVarName() + " == rhs." + col.second.printVarName() + " &&\n";
    si += space + space + "1;\n";
    si += "}\n\n";

    // operator->()
    if (isProxy)
    {
        s += space + "IdPtr<" + getParentName() + "> operator->() const;\n";
        si += "IdPtr<" + getParentName() + "> " + getCppName() + "::operator->() const\n";
        si += "{\n";
        si += space + "if (" + getParentVariableName() + ")\n";
        si += space + space + "return " + getParentVariableName() + ";\n";
        si += space + "throw EXCEPTION(\"Value is missing\");\n";
        si += "}\n\n";
    }

    //
    // private functions
    //
    s += "\n";
    s += "private:\n";
    
    // loadFromSqlite3()
    s += space + "int loadFromSqlite3(int, char**, char**);\n";
    si += "int " + getCppName() + "::loadFromSqlite3(int ncols, char **cols, char **names)\n";
    si += "{\n";
    for (auto &col : cols)
        si += space + "if (cols[" + to_string(col.getId()) + "]) " + col.printLoad() + ";\n";
    si += "\n";
    si += space + "return 0;" + "\n";
    si += "}\n\n";
    s += "\n";

    //
    // friends
    //
    s += space + "friend class " + storageImpl + ";\n";
    s += space + "template <typename T> friend struct IdPtr;\n";
    s += "\n";

    //
    // static functions
    //
    s += "public:\n";
    s += space + "static const char *getSql();\n";
    si += "const char *" + getCppName() + "::getSql()\n";
    si += "{\n";
    auto sql_ = sql;
    replaceAll(sql_, "\n", " \\\n");
    replaceAll(sql_, "\"", "\\\"");
    si += space + "return\n" + space + "\" \\\n" + sql_ + " \\\n" + space + "\";\n";
    si += "}\n\n";

    s += "};\n\n";
    return s;
}

string Table::printIo(const Tables &tables, string &impl)
{
    string s;
    s += printLoad(impl);
    s += printLoadPtrs(impl);
    s += printLoadArrays(tables, impl);
    s += printSave(impl);
    return s;
}

string Table::printLoad(string &si)
{
    string s;
    s += space + "void _load" + name + "();\n";
    si += "void " + storageImpl + "::_load" + name + "()\n";
    si += "{\n";
    {
        si += space + "auto callback = [this](int ncols, char **cols, char **names)" + "\n";
        si += space + "{" + "\n";
        {
            string space = ::space + ::space;
            string name = getCppName();
            string var = getVariableName();
            si += space + "Ptr<" + name + "> " + var + " = std::make_shared<" + name + ">();" + "\n";
            si += space + "int ret = " + var + "->" + "loadFromSqlite3(ncols, cols, names);" + "\n";
            if (hasIdField)
                si += space + getVariableArrayName() + "[" + var + "->id] = " + var + ";" + "\n";
            else
                si += space + getVariableArrayName() + ".push_back(" + var + ");" + "\n";
            si += space + "return ret;" + "\n";
        }
        si += space + "};" + "\n";
        si += space + "db->execute(\"select * from " + name + ";\", callback);\n";
    }
    si += "}\n\n";
    return s;
}

string Table::printLoadPtrs(string &si)
{
    string s;
    s += space + "void _load" + name + "Ptrs();\n";
    si += "void " + storageImpl + "::_load" + name + "Ptrs()\n";
    si += "{\n";
    if (!fks.empty())
    {
        set<Column> cols = mapToSet(columns);
        si += space + "for (auto &" + getVariableName() + " : " + getVariableArrayName() + ")\n";
        si += space + "{\n";
        for (auto &col : cols)
        {
            string space = ::space + ::space;
            string name = getCppName();
            string var = getVariableName();
            auto fk = col.getFk();
            if (fk)
            {
                string name2 = toVarName(fk->table_name);
                if (hasIdField)
                {
                    si += space + "if (" + name2 + ".find(" + var + ".second->" + col.getCleanName() + ".id) != " + name2 + ".end())" + "\n";
                    si += space + ::space + (toVarName(name)) + ".second->" + col.getCleanName() + ".ptr = " +
                        name2 + "[" + var + ".second->" + col.getCleanName() + ".id]";
                    si += ";\n";
                }
                else
                {
                    si += space + "if (" + name2 + ".find(" + var + "->" + col.getCleanName() + ".id) != " + name2 + ".end())" + "\n";
                    si += space + ::space + var + "->" + col.getCleanName() + ".ptr = " +
                        name2 + "[" + var + "->" + col.getCleanName() + ".id]";
                    si += ";\n";
                }
            }
        }
        si += space + "}\n";
    }
    si += "}\n\n";
    return s;
}

string Table::printLoadArrays(const Tables &tables, string &si)
{
    string s;
    s += space + "void _load" + name + "Arrays();\n";
    si += "void " + storageImpl + "::_load" + name + "Arrays()\n";
    si += "{\n";
    {
        string name = getCppName();
        set<Column> cols = mapToSet(columns);
        if (container)
        {
            si += space + "for (auto &" + getVariableName() + " : " + getVariableArrayName() + ")" + "\n";
            si += space + "{\n";
            for (auto &table : contains)
            {
                string space = ::space + ::space;
                si += space + "for (auto &" + table->getVariableName() + " : " + table->getVariableArrayName() + ")\n";
                {
                    string space = ::space + ::space + ::space;
                    si += space + "if (" + getVariableName() + ".first == " + table->getVariableName() + (table->hasIdField ? ".second" : "") + "->" + getVariableName() + ".id)\n";
                    {
                        string space = ::space + ::space + ::space + ::space;
                        si += space + getVariableName() + ".second->" + table->getChildVariableArrayName(table->getParentName()) + ".push_back(" + table->getVariableName() + (table->hasIdField ? ".second" : "") + ");\n";
                    }
                }
            }
            si += space + "}\n";
        }
    }
    si += "}\n\n";
    return s;
}

string Table::printSave(string &si)
{
    string s;
    s += space + "void _save" + name + "() const;\n";
    si += "void " + storageImpl + "::_save" + name + "() const\n";
    si += "{\n";
    {
        si += space + "std::string query;" + "\n";
        si += space + "query += \"delete from " + name + ";\"" + ";\n";
        si += space + "db->execute(query.c_str());\n";
        si += space + "query.clear();\n";
        si += space + "if (" + toVarName(name) + ".empty())" + "\n";
        si += space + ::space + "return;\n";
        si += space + "query += \"insert or replace into " + name + " values\\n\"" + ";\n";
        si += space + "for (auto &" + getVariableName() + " : " + toVarName(name) + ")" + "\n";
        si += space + "{\n";
        {
            string space = ::space + ::space;
            si += space + "query += \"(\";\n";
            auto cols = mapToSet(columns);
            for (auto &col : cols)
                si += space + "query += \"'\" + " + col.printSave(getVariableName() + (hasIdField ? ".second" : "")) + " + \"',\";\n";
            si += space + "query.resize(query.size() - 1);\n";
            si += space + "query += \"),\\n\";\n";
        }
        si += space + "}\n";
        si += space + "query.resize(query.size() - 2);\n";
        si += space + "query += \";\";\n";
        si += space + "db->execute(query.c_str());\n";
    }
    si += "}\n\n";
    return s;
}

string Table::printUsing()
{
    string s;
    s += "using detail::" + getCppName() + ";\n";
    return s;
}

string Table::printAddDeleteRecord(string &si)
{
    string s;

    // add record
    s += space + "virtual Ptr<" + getCppName() + "> add" + getCppName() + "(IObject *parent = 0);\n";
    si += "Ptr<" + getCppName() + "> " + storageImpl + "::add" + getCppName() + "(IObject *parent)\n";
    si += "{\n";
    if (isMapTable)
    {
        si += space + "int id = 1;\n";
        si += space + "if (!" + getVariableArrayName() + ".empty())" + "\n";
        si += space + ::space + "id = " + getVariableArrayName() + ".rbegin()->first + 1;" + "\n";
        si += space + "auto v = std::make_shared<" + getCppName() + ">();" + "\n";
        si += space + "v->id = id;" + "\n";
        si += space + "" + getVariableArrayName() + "[v->id] = v;" + "\n";

        string var = getParentVariableName();
        si += space + getParentName() + " *" + var + " = (" + getParentName() + " *)parent;" + "\n";
        si += space + var + "->" + getChildVariableArrayName(getParentName()) + ".push_back(v);" + "\n";
        si += space + "v->" + var + " = " + var + "s[" + var + "->id];" + "\n";
    }
    else
    {
        if (hasIdField)
        {
            si += space + "int id = 1;\n";
            si += space + "if (!" + getVariableArrayName() + ".empty())" + "\n";
            si += space + ::space + "id = " + getVariableArrayName() + ".rbegin()->first + 1;" + "\n";
            si += space + "auto v = std::make_shared<" + getCppName() + ">();" + "\n";
            si += space + "v->id = id;" + "\n";
            si += space + getVariableArrayName() + "[v->id] = v;" + "\n";
        }
        else if (!hasParent)
        {
            si += space + "auto v = std::make_shared<" + getCppName() + ">();" + "\n";
            si += space + getVariableArrayName() + ".push_back(v);" + "\n";
        }
        else
        {
            string var = getParentVariableName();
            si += space + "auto v = std::make_shared<" + getCppName() + ">();" + "\n";
            si += space + getParentName() + " *" + var + " = (" + getParentName() + " *)parent;" + "\n";
            si += space + var + "->" + getChildVariableArrayName(getParentName()) + ".push_back(v);" + "\n";
            si += space + getVariableArrayName() + ".push_back(v);" + "\n";
            si += space + "v->" + var + " = " + getParentVariableArrayName() + "[" + var + "->id];" + "\n";
        }
    }
    si += space + "return v;\n";
    si += "}\n\n";

    // delete record
    s += space + "virtual void delete" + getCppName() + "(" + getCppName() + " *object);\n";
    si += "void " + storageImpl + "::delete" + getCppName() + "(" + getCppName() + " *v)\n";
    si += "{\n";
    if (container || hasIdField)
    {
        si += space + getVariableArrayName() + ".erase(v->id);" + "\n";
    }
    else
    {
        string var = getVariableArrayName();
        si += space + "while (1)\n";
        si += space + "{\n";
        {
            string space = ::space + ::space;
            si += space + "auto i = find_if(" +
                var + ".begin(), " + var + ".end(), " +
                "[v](const Ptr<" + getCppName() + "> &p)" +
                "{ return p.get() == v; });" + "\n";
            si += space + "if (i == " + var + ".end())\n";
            si += space + ::space + "break;\n";
            si += space + var + ".erase(i);\n";
        }
        si += space + "}\n";
    }
    si += "}\n\n";
    return s;
}

string Database::printTypes(string &si)
{
    string s;
    s += autogenerated_warning_h;
    si += autogenerated_warning;
    s += "#include \"../Types.h\"\n\n";
    s += "namespace polygon4\n{\n\n";
    s += "namespace detail\n{\n\n";
    s += "enum class EObjectType : int\n";
    s += "{\n";
    s += space + "None,\n\n";
    for (auto &table : tables)
        s += space + table.second.getCppName() + ",\n";
    s += "\n";
    s += space + anyType + ",\n";
    s += "};\n\n";
    for (auto &table : tables)
        s += table.second.printForward();
    s += "\n";
    s += "class IObject\n";
    s += inheritQObject();
    s += "{\n";
    s += declareQObject();
    s += space + "friend class " + storageImpl + ";\n";
    s += space + "template <typename T> friend struct IdPtr;\n";
    s += "\n";
    s += "public:\n";
    s += space + "virtual ~IObject(){}\n";
    s += "\n";
    s += space + "virtual EObjectType getType() const = 0;\n";
    s += space + "virtual Text getVariableString(int columnId) const = 0;\n";
    s += space + "virtual void setVariableString(int columnId, Text text, Ptr<IObject> ptr = Ptr<IObject>()) = 0;\n";
    s += space + "virtual Text getName() const;\n";
    si += "Text IObject::getName() const\n";
    si += "{\n";
    si += space + "return POLYGON4_NONAME;\n";
    si += "}\n\n";
    s += "#ifdef USE_QT\n";
    s += space + "virtual QTreeWidgetItem *printQtTreeView(QTreeWidgetItem *parent) const = 0;\n";
    s += "#endif\n";
    s += "\n";
    s += space + "bool operator<(const IObject &rhs) const\n";
    s += space + "{\n";
    s += space + space + "return getName() < rhs.getName();\n";
    s += space + "}\n";
    s += "};\n\n";
    for (auto &table : tables)
        s += table.second.print(tables, si);
    s += "}\n\n}\n\n";
    return s;
}

string Database::printStorage(string &si)
{
    string s;
    s += autogenerated_warning_h;
    s += "class Storage\n";
    s += "{\n";
    s += "public:\n";
    for (auto &table : tables)
        s += space + table.second.getArrayType() + "<Ptr<" + table.second.getCppName() + ">> " + table.second.getVariableArrayName() + ";\n";
    s += "\n";
    s += "public:\n";
    s += space + "virtual void create() const = 0;\n";
    s += space + "virtual void clear() = 0;\n";
    s += space + "virtual void load(ProgressCallback callback = ProgressCallback()) = 0;\n";
    s += space + "virtual void save(ProgressCallback callback = ProgressCallback()) const = 0;\n";
    s += "\n";
    s += "#ifdef USE_QT\n";
    s += space + "virtual void printQtTreeView(QTreeWidgetItem *root) const = 0;\n";
    s += space + "virtual QTreeWidgetItem *addRecord(QTreeWidgetItem *item) = 0;\n";
    s += space + "virtual void deleteRecord(QTreeWidgetItem *item) = 0;\n";
    s += "#endif\n";
    s += "\n";
    s += space + "virtual OrderedObjectMap getOrderedMap(EObjectType type) const = 0;\n";
    s += "\n";
    s += printAddDeleteRecordVirtual();
    s += "};\n\n";
    return s;
}

string Database::printStorageImpl(string &si)
{
    string s;
    s += autogenerated_warning_h;
    si += autogenerated_warning;
    s += "class StorageImpl : public Storage\n";
    s += "{\n";
    s += "#ifdef USE_QT\n";
    s += space + "Q_DECLARE_TR_FUNCTIONS(StorageImpl)\n";
    s += "#endif\n\n";
    s += "private:\n";
    s += space + "Ptr<Database> db;" + "\n";
    s += "\n";
    s += "private:\n";
    for (auto &table : tables)
        s += table.second.printIo(tables, si) + "\n";
    s += "public:\n";
    s += space + "StorageImpl(Ptr<Database> db) : db(db) {}" + "\n";
    s += "\n";
    s += space + "void setDb(Ptr<Database> db) { this->db = db; }\n";
    s += "\n";

    // create()
    s += space + "virtual void create() const;\n";
    si += "void " + storageImpl + "::create() const\n";
    si += "{\n";
    for (auto &table : tables)
        si += space + "db->execute(" + table.second.getCppName() + "::getSql()" + ");\n";
    si += "}\n\n";

    // clear()
    s += space + "virtual void clear();\n";
    si += "void " + storageImpl + "::clear()\n";
    si += "{\n";
    for (auto &table : tables)
        si += space + table.second.getVariableArrayName() + ".clear();\n";
    si += "}\n\n";
    
    double step = 100.0 / (tables.size() * 3.0);
    double progress = 0;
    s += space + "virtual void load(ProgressCallback callback = ProgressCallback());\n";
    si += "void " + storageImpl + "::load(ProgressCallback callback)\n";
    si += "{\n";
    for (auto &table : tables)
    {
        si += space + "_load" + table.first + "();\n";
        si += space + "PROGRESS_CALLBACK(" + to_string(progress += step) + ");\n";
    }
    si += "\n";
    for (auto &table : tables)
    {
        si += space + "_load" + table.first + "Ptrs();\n";
        si += space + "PROGRESS_CALLBACK(" + to_string(progress += step) + ");\n";
    }
    si += "\n";
    for (auto &table : tables)
    {
        si += space + "_load" + table.first + "Arrays();\n";
        si += space + "PROGRESS_CALLBACK(" + to_string(progress += step) + ");\n";
    }
    si += "}\n\n";
    
    step = 100.0 / double(tables.size());
    progress = 0;
    s += space + "virtual void save(ProgressCallback callback = ProgressCallback()) const;\n";
    si += "void " + storageImpl + "::save(ProgressCallback callback) const\n";
    si += "{\n";
    auto tbls = mapToSet(tables);
    for (auto &table : tbls)
    {
        si += space + "_save" + table.getName() + "();\n";
        si += space + "PROGRESS_CALLBACK(" + to_string(progress += step) + ");\n";
    }
    si += "}\n\n";

    s += "\n";
    s += printAddDeleteRecord(si);
    s += "\n";
    si += "\n";

    s += "#ifdef USE_QT\n";
    si += "#ifdef USE_QT\n";
    s += printQtTreeView(si);
    si += "#endif\n\n";
    s += "#endif\n";
    s += printGetOrderedMap(si);
    s += "};\n\n";
    return s;
}

string Database::printAddDeleteRecordVirtual()
{
    string s;
    for (auto &table : tables)
    {
        s += space + "virtual Ptr<" + table.second.getCppName() + "> add" + table.second.getCppName() + "(IObject *parent = 0) = 0;\n";
        s += space + "virtual void delete" + table.second.getCppName() + "(" + table.second.getCppName() + " *object) = 0;\n";
    }
    s += "\n";
    s += space + "virtual Ptr<IObject> addRecord(IObject *parent = 0) = 0;\n";
    s += space + "virtual void deleteRecord(IObject *data) = 0;\n";
    return s;
}

string Database::printAddDeleteRecord(string &si)
{
    string s;
    for (auto &table : tables)
        s += table.second.printAddDeleteRecord(si);
    s += "\n";

    s += space + "virtual Ptr<IObject> addRecord(IObject *parent = 0);\n";
    si += "Ptr<IObject> " + storageImpl + "::addRecord(IObject *parent)\n";
    si += "{\n";
    si += space + "EObjectType type = parent->getType();\n";
    si += space + "switch (type)\n";
    si += space + "{\n";
    for (auto &table : tables)
    {
        si += ::space + "case EObjectType::" + table.second.getCppName() + ":" + "\n";
        si += space + space + "return add" + table.second.getCppName() + "(parent);" + "\n";

    }
    si += space + "default:" + "\n";
    si += space + space + "return Ptr<IObject>(0);\n";
    si += space + "}\n";
    si += "}\n\n";

    s += space + "virtual void deleteRecord(IObject *data);\n";
    si += "void " + storageImpl + "::deleteRecord(IObject *data)\n";
    si += "{\n";
    si += space + "EObjectType type = data->getType();\n";
    si += space + "switch (type)\n";
    si += space + "{\n";
    for (auto &table : tables)
    {
        string space = ::space + ::space;
        si += ::space + "case EObjectType::" + table.second.getCppName() + ":" + "\n";
        si += space + "delete" + table.second.getCppName() + "((" + table.second.getCppName() + " *)data);" + "\n";
        si += space + "break;\n";
    }
    si += space + "default:" + "\n";
    si += space + space + "break;\n";
    si += space + "}\n";
    si += "}\n";
    return s;
}

string Database::printQtTreeView(string &si)
{
    string s;

    s += space + "virtual void printQtTreeView(QTreeWidgetItem *root) const;\n";
    si += "void " + storageImpl + "::printQtTreeView(QTreeWidgetItem *root) const\n";
    si += "{\n";
    si += space + "QTreeWidgetItem *item;\n";
    for (auto &table : tables)
    {
        if (!table.second.isVisibleInTreeView())
            continue;
        si += "\n";
        si += space + "item = new QTreeWidgetItem(root, QStringList(" + tr(splitWords(table.second.getName())) + "));" + "\n";
        si += space + "item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::" + table.second.getCppName() + "));" + "\n";
        si += space + "auto " + table.second.getVariableArrayName() + " = getOrderedMap(EObjectType::" + table.second.getCppName() + ");\n";
        si += space + "for (auto &" + table.second.getVariableName() + " : " + table.second.getVariableArrayName() + ")\n";
        si += space + space + table.second.getVariableName() + ".second->printQtTreeView(item);" + "\n";
    }
    si += "}\n\n";

    s += space + "virtual QTreeWidgetItem *addRecord(QTreeWidgetItem *item);\n";
    si += "QTreeWidgetItem *" + storageImpl + "::addRecord(QTreeWidgetItem *item)\n";
    si += "{\n";
    si += space + "EObjectType type = static_cast<EObjectType>(item->data(0, Qt::UserRole).toInt());\n";
    si += space + "IObject *parent = 0;" + "\n";
    si += space + "auto parentItem = item->parent();" + "\n";
    si += space + "if (parentItem)" + "\n";
    si += space + space + "parent = (IObject *)parentItem->data(0, Qt::UserRole).toULongLong();" + "\n";
    si += space + "switch (type)\n";
    si += space + "{\n";
    for (auto &table : tables)
    {
        si += ::space + "case EObjectType::" + table.second.getCppName() + ":" + "\n";
        string space = ::space + ::space;
        si += space + "return add" + table.second.getCppName() + "(parent)->printQtTreeView(item);" + "\n";
    }
    si += space + "default:" + "\n";
    si += space + space + "return 0;\n";
    si += space + "}\n";
    si += "}\n\n";

    s += space + "virtual void deleteRecord(QTreeWidgetItem *item);\n";
    si += "void " + storageImpl + "::deleteRecord(QTreeWidgetItem *item)\n";
    si += "{\n";
    si += space + "IObject *data = (IObject *)item->data(0, Qt::UserRole).toULongLong(); " + "\n";
    si += space + "EObjectType type = data->getType();\n";
    si += space + "switch (type)\n";
    si += space + "{\n";
    for (auto &table : tables)
    {
        string space = ::space + ::space;
        si += ::space + "case EObjectType::" + table.second.getCppName() + ":" + "\n";
        si += space + "delete" + table.second.getCppName() + "((" + table.second.getCppName() + " *)data);" + "\n";
        si += space + "break;\n";
    }
    si += space + "default:" + "\n";
    si += space + space + "break;\n";
    si += space + "}\n";
    si += space + "item->parent()->removeChild(item);" + "\n";
    si += "}\n";

    return s;
}

string Database::printTypesUsing()
{
    string s;
    s += autogenerated_warning_h;
    for (auto &table : tables)
        s += table.second.printUsing();
    return s;
}

string Database::printHelpers(string &si)
{
    string s;
    s += autogenerated_warning_h;
    si += autogenerated_warning;
    
    // getTableType()
    s += "EObjectType getTableType(const std::string &table);\n";
    si += "EObjectType getTableType(const std::string &table)\n";
    si += "{\n";
    si += space + "static std::map<std::string, EObjectType> types =\n";
    si += space + "{\n";
    {
        string space = ::space + ::space;
        for (auto &table : tables)
            si += space + "{ \"" + table.second.getName() + "\", EObjectType::" + table.second.getCppName() + " },\n";
        si += space + "{ \"" + anyTable + "\", EObjectType::" + anyType + " },\n";
        
    }
    si += space + "};\n";
    si += space + "return types[table];\n";
    si += "};\n\n";
    
    // getTableNameByType()
    s += "std::string getTableNameByType(EObjectType type);\n";
    si += "std::string getTableNameByType(EObjectType type)\n";
    si += "{\n";
    si += space + "static std::map<EObjectType, std::string> tables =\n";
    si += space + "{\n";
    {
        string space = ::space + ::space;
        for (auto &table : tables)
            si += space + "{ EObjectType::" + table.second.getCppName() + ", \"" + table.second.getName() + "\" },\n";
        si += space + "{ EObjectType::" + anyType + ", \"" + anyTable + "\" },\n";
    }
    si += space + "};\n";
    si += space + "return tables[type];\n";
    si += "};\n\n";
    
    s += "#ifdef USE_QT\n";
    si += "#ifdef USE_QT\n";

    // retranslateFieldNames()
    s += "void retranslateFieldNames();\n";
    si += "typedef std::map<std::string, QString> FieldNames;\n\n";
    si += "FieldNames fieldNames;\n\n";
    si += "void retranslateFieldNames()\n";
    si += "{\n";
    si += space + "FieldNames names =\n";
    si += space + "{\n";
    {
        set<string> fields;
        for (auto &table : tables)
            for (auto &col : table.second.getColumns())
                fields.insert(col.second.getName());
        string space = ::space + ::space;
        for (auto &f : fields)
            si += space + "{ \"" + f + "\", " + tr(f) + " },\n";
    }
    si += space + "};\n";
    si += space + "fieldNames = names;\n";
    si += "};\n\n";

    // getFieldName()
    s += "QString getFieldName(const std::string &name);\n";
    si += "QString getFieldName(const std::string &name)\n";
    si += "{\n";
    si += space + "return fieldNames[name];\n";
    si += "};\n\n";

    // retranslateTableNames()
    s += "void retranslateTableNames();\n";
    si += "typedef std::map<std::string, QString> TableNames;\n\n";
    si += "TableNames tableNames;\n\n";
    si += "void retranslateTableNames()\n";
    si += "{\n";
    si += space + "TableNames names =\n";
    si += space + "{\n";
    {
        string space = ::space + ::space;
        for (auto &t : tables)
            si += space + "{ \"" + t.second.getName() + "\", " + tr(splitWords(t.second.getName())) + " },\n";
        si += space + "{ \"" + anyTable + "\", " + tr(splitWords(anyTable)) + " },\n";
    }
    si += space + "};\n";
    si += space + "tableNames = names;\n";
    si += "};\n\n";

    // getTableName()
    s += "QString getTableName(const std::string &name);\n";
    si += "QString getTableName(const std::string &name)\n";
    si += "{\n";
    si += space + "return tableNames[name];\n";
    si += "};\n";

    s += "#endif\n";
    si += "#endif\n";

    return s;
}

string Database::printGetOrderedMap(string &si)
{
    string s;
    s += space + "virtual OrderedObjectMap getOrderedMap(EObjectType type) const;\n";
    si += "OrderedObjectMap " + storageImpl + "::getOrderedMap(EObjectType type) const\n";
    si += "{\n";
    si += space + "switch (type)\n";
    si += space + "{\n";
    for (auto &table : tables)
    {
        string space = ::space + ::space;
        si += ::space + "case EObjectType::" + table.second.getCppName() + ":" + "\n";
        si += space + "return ::getOrderedMap(" + table.second.getVariableArrayName() + ");\n";
    }
    si += space + "default:" + "\n";
    si += space + space + "return OrderedObjectMap();\n";
    si += space + "}\n";
    si += "}\n";
    return s;
}

string Database::printPy()
{
    string s;
    s += "#!/usr/bin/python3\n";
    s += "# -*- coding: utf-8 -*-\n\n";
    s += "tables = [\n";
    for (auto &table : tables)
        s += space + "'" + table.second.getVariableArrayName() + "'" + ",\n";
    s += "]\n";
    return s;
}

void Database::init()
{
    for (auto &table : tables)
        table.second.init(tables);
}