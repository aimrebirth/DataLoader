#include "data.h"

const std::string autogenerated_warning = "/* DO NOT EDIT! This is an autogenerated file. */";
const std::string pragma_once = "#pragma once";

const string space = "    ";
const string String = "String";
const string storageImpl = "StorageImpl";
const string anyTable = "AnyTable";
const string anyType = "Any";
const string arrayType = "CTable";
const string dataClassPtr = "Ptr";
const string idAccess = "->id";
const string iObject = "IObjectBase";

const map<string, string> objectNames = 
{
    { "Players", "to_string(mechanoid)" },
    { "ScriptVariables", "variable" },
    { "ClanReputations", "clan->getId() < clan2->getId() ? (to_wstring(clan) + L\" - \" + to_wstring(clan2)) : (to_wstring(clan2) + L\" - \" + to_wstring(clan))" },
    { "MapBuildings", "to_string(building)" },
    { "MapObjects", "to_string(object)" },
    { "MapGoods", "to_string(good)" },
    { "Coordinates", "to_string(*this)" },
    { "QuestRewards", "to_string(quest)" },
    { "Maps", "text_id" },
};

enum class ObjectName
{
    onText,
    onName,
    onParent,
    onCustom,
};

const map<string, vector<ObjectName>> objectNamesOrder = 
{
    { "", { ObjectName::onCustom, ObjectName::onName, ObjectName::onText, ObjectName::onParent } },
    { "Maps", { ObjectName::onText, ObjectName::onName, ObjectName::onCustom, ObjectName::onParent } },
    { "MapBuildings", { ObjectName::onText, ObjectName::onName, ObjectName::onCustom, ObjectName::onParent } },
    { "MapObjects", { ObjectName::onText, ObjectName::onName, ObjectName::onCustom, ObjectName::onParent } },
    { "MapGoods", { ObjectName::onText, ObjectName::onName, ObjectName::onCustom, ObjectName::onParent } },
};

string splitWords(string s)
{
    string r;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (isupper(s[i]) && i)
            r += " ";
        r += s[i];
    }
    return r;
}

string tr(string s)
{
    return "QCoreApplication::translate(\"DB\", \"" + s + "\")";
}

string trUE4(string s)
{
    return "LOCTEXT(\"DB\", \"" + s + "\")";
}

template<typename T, typename K>
set<T> mapToSet(const map<K, T> &map)
{
    set<T> s;
    for (auto &v : map)
        s.insert(v.second);
    return s;
}

string Column::getCppType() const
{
    string s;
    switch (type)
    {
    case ColumnType::Integer:
        s += "int";
        break;
    case ColumnType::Real:
        s += "float";
        break;
    case ColumnType::Text:
        s += "Text";
        break;
    case ColumnType::Blob:
        s += "Blob";
        break;
    }
    return s;
}

string Column::getDefaultValue() const
{
    string s;
    switch (type)
    {
    case ColumnType::Integer:
        s += defaultValue.empty() ? "0" : defaultValue;
        break;
    case ColumnType::Real:
        s += defaultValue.empty() ? "0.0f" : defaultValue;
        break;
    case ColumnType::Text:
        s += defaultValue;
        break;
    case ColumnType::Blob:
        break;
    }
    return s;
}

string Column::printVar() const
{
    string s;
    if (fk)
    {
        s += "" + dataClassPtr + "<" + fk->table->getCppName() + "> " + printVarName() + 
            " = std::make_shared<" + fk->table->getCppName() + ">()";
        //s += "" + dataClassPtr + "<" + fk->table->getCppName() + "> " + printVarName();
    }
    else
    {
        s += getCppType() + " " + printVarName();
        if (type == ColumnType::Integer || type == ColumnType::Real)
            s += " = " + getDefaultValue();
    }
    return s;
}

string Column::printVarName() const
{
    string s;
    if (fk)
        s += getCleanName();
    else
        s += name;
    return s;
}

string Column::printLoadSqlite3(string var) const
{
    string s;
    s += var + "->" + (fk ? removeId(name) + idAccess : name) + " = ";
    switch (type)
    {
    case ColumnType::Integer:
        s += "sqlite3_column_int";
        break;
    case ColumnType::Real:
        s += "(float)sqlite3_column_double";
        break;
    case ColumnType::Text:
        s += "(const char *)sqlite3_column_text";
        break;
    case ColumnType::Blob:
        s += "Blob(sqlite3_column_blob(stmt, " + to_string(id) + "), sqlite3_column_bytes(stmt, " + to_string(id) + "))";
        break;
    }
    if (type != ColumnType::Blob)
        s += "(stmt, " + to_string(id) + ")";
    return s;
}

string Column::printSet() const
{
    string s;
    if (fk)
    {
        s += getCleanName() + idAccess + " = std::stoi(to_string(text))";
    }
    else
    {
        s += name + " = ";
        switch (type)
        {
        case ColumnType::Integer:
            s += "std::stoi(to_string(text))";
            break;
        case ColumnType::Real:
            s += "std::stof(to_string(text))";
            break;
        case ColumnType::Text:
            s += "to_string(text)";
            break;
        case ColumnType::Blob:
            s += "text";
            break;
        }
    }
    return s;
}

string Column::printSetPtr() const
{
    string s;
    if (fk)
    {
        s += getCleanName() + " = std::static_pointer_cast<" + fk->table->getCppName() + ">(ptr)";
    }
    return s;
}

string Column::printSaveSqlite3(string var) const
{
    string s;
    if (fk)
    {
        s += "sqlite3_bind_int(stmt, " + to_string(id + 1) + ", " + var + "->" + removeId(name) + idAccess + ")";
    }
    else
    {
        switch (type)
        {
        case ColumnType::Integer:
            s += "sqlite3_bind_int(stmt, " + to_string(id + 1) + ", " + var + "->" + name + ")";
            break;
        case ColumnType::Real:
            s += "sqlite3_bind_double(stmt, " + to_string(id + 1) + ", " + var + "->" + name + ")";
            break;
        case ColumnType::Text:
            s += "sqlite3_bind_text(stmt, " + to_string(id + 1) + ", to_string(" + var + "->" + name + 
                ").c_str()" + ", -1, SQLITE_TRANSIENT)";
            break;
        case ColumnType::Blob:
            s += "sqlite3_bind_blob(stmt, " + to_string(id + 1) + ", " +
                var + "->" + name + ".getRawData()" + ", " + 
                var + "->" + name + ".getLength()" + 
                ", SQLITE_TRANSIENT)";
            break;
        }
    }
    return s;
}

string Table::getParentName() const
{
    string p = splitWords(getCppName());
    int pos = p.rfind(' ');
    if (pos == -1)
        return "";
    p = p.substr(0, pos);
    replaceAll(p, " ", "");
    return p;
}

bool Table::isVisibleInTreeView() const 
{
    return
        !hasParent &&
        name != "Tables" &&
        1;
}

void Table::init(Tables &tables)
{
    auto tbls = tables;
    const auto pn = getParentName();
    hasParent = !pn.empty() && find_if(tables.begin(), tables.end(), [&](const decltype(tbls)::value_type &v){ return v.second.getCppName() == pn; }) != tables.end();
    hasChild = !pn.empty() && find_if(tables.begin(), tables.end(), [&](const decltype(tbls)::value_type &v){ return v.second.getCppName() == getChildName(pn); }) != tables.end();
    hasIdField = find_if(columns.begin(), columns.end(), [](const decltype(columns)::value_type &v){ return v.second.isId(); }) != columns.end();
    isMapTable = hasParent && hasChild && hasIdField;
    isProxy = !hasIdField && hasParent && hasChild;
    
    // assign pks
    for (auto &pk : pks)
        columns[pk].setPk();

    // assign fks
    for (auto &fk : fks)
    {
        auto &table = tables[fk.second.table_name];
        fk.second.table = &table;
        fk.second.column = &table.columns[fk.second.column_name];
        columns[fk.first].setFk(&fk.second);
        table.linksToThisTable.insert(name);
    }

    // check if container
    for (auto &table : tables)
    {
        auto &t = table.second;
        if (t.getParentName() == getCppName())
        {
            container = true;
            contains.push_back(&t);
        }
    }

    if (name == "Tables")
    {
        string s;
        s += "insert into \"Tables\" (\"text_id\") values\n";
        for (auto &table : tables)
            s += "(\"" + table.second.getName() + "\"),\n";
        s += "(\"" + anyTable + "\"),\n";
        s.resize(s.size() - 2);
        s += ";";
        sql += "\n" + s;
    }
}

ModuleContext Table::print() const
{
    ModuleContext mc;
    const auto cols = mapToSet(columns);

    // localization types
    {
        if (getCppName() == String)
        {
            mc.hpp.beginBlock("enum class LocalizationType : EnumType");
            auto iter = cols.begin();
            while (iter->getName() != "ru")
                iter = next(iter);
            for (auto i = iter; i != cols.end(); i++)
                mc.hpp.addLine(i->getName() + ",");
            mc.hpp.addLine();
            mc.hpp.addLine("max,");
            mc.hpp.endBlock(true);
            mc.hpp.addLine();
        }
    }

    // class
    {
        mc.hpp.beginBlock("class DLL_EXPORT " + getCppName() + " : public I" + getCppName());
        mc.hpp.addLine("// data");
        mc.hpp.addLineNoSpace("public:");
        for (auto &col : cols)
        {
            if (!col.isId())
                mc.hpp.addLine(col.printVar() + ";");
        }
        mc.hpp.decreaseIndent();
    }

    // containers
    {
        if (container)
            mc.hpp.addLine();
        mc.hpp.increaseIndent();
        for (auto &t : contains)
            mc.hpp.addLine(arrayType + "<" + t->getCppName() + "> " + t->getChildVariableArrayName(getCppName()) + ";");
        mc.hpp.addLine();
    }

    mc.hpp.addLine("// constructors");
    mc.hpp.addLineNoSpace("public:");

    // constructors
    {
        mc.hpp.addLine(getCppName() + "() = default;");
        mc.hpp.addLine(getCppName() + "(const " + getCppName() + " &);");
        mc.hpp.addLine(getCppName() + " &operator=(const " + getCppName() + " &);");
        mc.hpp.addLine(getCppName() + "(" + getCppName() + " &&) = default;");
        mc.hpp.addLine(getCppName() + " &operator=(" + getCppName() + " &&) = default;");
        mc.hpp.addLine("virtual ~" + getCppName() + "();");

        // copy ctor
        mc.cpp.beginFunction(getCppName() + "::" + getCppName() + "(const " + getCppName() + " &rhs)");
        mc.cpp.addLine("copyFrom(rhs);");
        mc.cpp.endFunction();

        // copy assign
        mc.cpp.beginFunction(getCppName() + " &" + getCppName() + "::operator=(const " + getCppName() + " &rhs)");
        mc.cpp.addLine("copyFrom(rhs);");
        mc.cpp.addLine("return *this;");
        mc.cpp.endFunction();

        // dtor
        mc.cpp.beginFunction(getCppName() + "::~" + getCppName() + "()");
        mc.cpp.endFunction();
    }

    mc.hpp.addLine();
    mc.hpp.addLine("// functions");
    mc.hpp.addLineNoSpace("public:");
    
    // getType()
    {
        mc.hpp.addLine("virtual EObjectType getType() const override;");

        mc.cpp.beginFunction("EObjectType " + getCppName() + "::getType() const");
        mc.cpp.addLine("return object_type;");
        mc.cpp.endFunction();
    }

    // getVariableString()
    {
        mc.hpp.addLine("virtual Text getVariableString(int columnId) const override;");

        mc.cpp.beginFunction("Text " + getCppName() + "::getVariableString(int columnId) const");
        mc.cpp.beginBlock("switch (columnId)", false);
        for (auto &col : cols)
        {
            if (col.getType() == ColumnType::Blob)
                continue;
            mc.cpp.addLine("case " + to_string(col.getId()) + ":");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return to_string(" + col.printVarName() + ");");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine(R"(return "";)");
        mc.cpp.endBlock(true);
        mc.cpp.addLine(R"(return "";)");
        mc.cpp.endFunction();
    }

    // setVariableString()
    {
        mc.hpp.addLine("virtual void setVariableString(int columnId, Text text, " + dataClassPtr + "<" + iObject + "> ptr = " + dataClassPtr + "<" + iObject + ">()) override;");

        mc.cpp.beginFunction("void " + getCppName() + "::setVariableString(int columnId, Text text, " + dataClassPtr + "<" + iObject + "> ptr)");
        mc.cpp.beginBlock("switch (columnId)", false);
        for (auto &col : cols)
        {
            mc.cpp.addLine("case " + to_string(col.getId()) + ":");
            mc.cpp.increaseIndent();
            if (col.getFk())
                mc.cpp.addLine(col.printSetPtr() + ";");
            else
                mc.cpp.addLine(col.printSet() + ";");
            mc.cpp.addLine("break;");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("break;");
        mc.cpp.endBlock(true);
        mc.cpp.endFunction();
    }

    // printQtTreeView()
    {
        mc.hpp.addLineNoSpace("#ifdef USE_QT");
        mc.hpp.addLine("virtual QTreeWidgetItem *printQtTreeView(QTreeWidgetItem *parent) const override;");
        mc.hpp.addLineNoSpace("#endif");

        mc.cpp.addLineNoSpace("#ifdef USE_QT");
        mc.cpp.beginFunction("QTreeWidgetItem *" + getCppName() + "::printQtTreeView(QTreeWidgetItem *parent) const");
        mc.cpp.addLine("auto item = new QTreeWidgetItem(parent, QStringList(getName().toQString()));");
        mc.cpp.addLine("item->setData(0, Qt::UserRole, (uint64_t)this);");
        if (container)
        {
            mc.cpp.addLine();
            mc.cpp.addLine("QTreeWidgetItem *root;");
            for (auto &t : contains)
            {
                mc.cpp.addLine();
                mc.cpp.addLine("root = new QTreeWidgetItem(item, QStringList(" + tr(splitWords(t->getChildArrayName(getCppName()))) + "));");
                mc.cpp.addLine("root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::" + t->getCppName() + "));");
                mc.cpp.addLine("for (auto &" + t->getChildVariableName(getCppName()) + " : " + t->getChildVariableArrayName(getCppName()) + ")");
                mc.cpp.increaseIndent();
                mc.cpp.addLine(t->getChildVariableName(getCppName()) + "->" + "printQtTreeView(root);");
                mc.cpp.decreaseIndent();
                mc.cpp.addLine("root->sortChildren(0, Qt::AscendingOrder);");
            }
            mc.cpp.addLine();
        }
        mc.cpp.addLine("item->sortChildren(0, Qt::AscendingOrder);");
        mc.cpp.addLine("return item;");
        mc.cpp.endBlock();
        mc.cpp.addLineNoSpace("#endif");
        mc.cpp.addLine();
    }

    // printUE4TreeView()
    {
        mc.hpp.ifdef("USE_UNREAL_EDITOR");
        mc.hpp.beginFunction("virtual UE4SPtrTreeViewItem printUE4TreeView() const override");
        mc.hpp.addLine("UE4SPtrTreeViewItem item = MakeShareable(new UE4TreeViewItem);");
        mc.hpp.addLine("item->Name = FText::FromString(std::to_wstring(getName()).c_str());");
        mc.hpp.addLine("item->Type = EObjectType::" + getCppName() + ";");
        mc.hpp.addLine("item->Object = const_cast<" + getCppName() + "*>(this);");
        if (container)
        {
            mc.hpp.addLine();
            mc.hpp.addLine("UE4SPtrTreeViewItem root;");
            for (auto &t : contains)
            {
                mc.hpp.addLine();
                mc.hpp.addLine("root = MakeShareable(new UE4TreeViewItem);");
                mc.hpp.addLine("item->Children.Add(root);");
                mc.hpp.addLine("root->Name = " + trUE4(splitWords(t->getChildArrayName(getCppName()))) + ";");
                mc.hpp.addLine("root->Type = EObjectType::" + t->getCppName() + ";");
                mc.hpp.addLine("for (auto &" + t->getChildVariableName(getCppName()) + " : " + t->getChildVariableArrayName(getCppName()) + ")");
                mc.hpp.increaseIndent();
                mc.hpp.addLine("root->Children.Add(" + t->getChildVariableName(getCppName()) + "->" + "printUE4TreeView());");
                mc.hpp.decreaseIndent();
                mc.hpp.addLine("root->Children.Sort([](const auto &i1, const auto &i2){ return i1->Name.CompareTo(i2->Name) < 0; });");
            }
            mc.hpp.addLine();
        }
        mc.hpp.addLine("item->Children.Sort([](const auto &i1, const auto &i2){ return i1->Name.CompareTo(i2->Name) < 0; });");
        mc.hpp.addLine("return item;");
        mc.hpp.endBlock();
        mc.hpp.endif();
        mc.hpp.addLine();
    }

    // getName()
    {
        mc.hpp.addLine("virtual Text getName() const override;");
        mc.hpp.addLine();

        mc.cpp.beginFunction("Text " + getCppName() + "::getName() const");
        if (getCppName() != String)
        {
            mc.cpp.addLine("Text s;");

            string return_add;
            auto iter = objectNamesOrder.find(getName());
            if (iter == objectNamesOrder.end())
                iter = objectNamesOrder.find("");
            auto checkReturn = [&]
            {
                mc.cpp.addLine("if (!s.empty())");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("return s" + return_add + ";");
                mc.cpp.decreaseIndent();
            };
            auto printTextColumn = [&](auto *c)
            {
                if (c == nullptr)
                    return;
                if (c->getType() == ColumnType::Text)
                    mc.cpp.addLine("s = " + c->printVarName() + ";");
                else
                    mc.cpp.addLine("s = to_string(" + c->printVarName() + ");");
                checkReturn();
            };
            for (auto &nameType : iter->second)
            {
                switch (nameType)
                {
                case ObjectName::onCustom:
                {
                    auto iter_object_name = objectNames.find(this->name);
                    if (iter_object_name != objectNames.end())
                    {
                        mc.cpp.addLine("s = " + iter_object_name->second + ";");
                        checkReturn();
                    }
                    break;
                }
                case ObjectName::onName:
                    printTextColumn(getNameColumn());
                    break;
                case ObjectName::onText:
                    printTextColumn(getTextColumn());
                    break;
                case ObjectName::onParent:
                    if (isProxy)
                    {
                        string var = getChildVariableName(getParentName());
                        mc.cpp.addLine("s = to_string(" + var + ");");
                        checkReturn();
                    }
                    break;
                }
            }
            mc.cpp.addLine("return " + iObject + "::getName()" + return_add + ";");
        }
        else
        {
            auto iter = cols.begin();
            while (iter->getName() != "ru")
                iter = next(iter);
            mc.cpp.addLine("auto s = ((Text *)&" + iter->getName() + ")[gCurrentLocalizationId];");
            mc.cpp.addLine("if (!s.empty())");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return s;");
            mc.cpp.decreaseIndent();
            mc.cpp.addLine("s = text_id;");
            mc.cpp.addLine("if (!s.empty())");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return s;");
            mc.cpp.decreaseIndent();
            mc.cpp.addLine("for (int i = 0; i < static_cast<int>(LocalizationType::max); i++)");
            mc.cpp.beginBlock();
            mc.cpp.addLine("s = ((Text *)&" + iter->getName() + ")[i];");
            mc.cpp.addLine("if (!s.empty())");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return s;");
            mc.cpp.decreaseIndent();
            mc.cpp.endBlock();
            mc.cpp.addLine("return s;");
        }
        mc.cpp.endFunction();
    }

    // operator==()
    {
        mc.hpp.addLine("bool operator==(const " + getCppName() + " &rhs) const;");

        mc.cpp.beginFunction("bool " + getCppName() + "::operator==(const " + getCppName() + " &rhs) const");
        mc.cpp.addLine("return");
        mc.cpp.increaseIndent();
        for (auto &col : columns)
            if (col.first != "id")
                mc.cpp.addLine(col.second.printVarName() + " == rhs." + col.second.printVarName() + " &&");
        mc.cpp.addLine("1;");
        mc.cpp.decreaseIndent();
        mc.cpp.endFunction();
    }

    // operator->()
    {
        if (isProxy)
        {
            mc.hpp.addLine("" + dataClassPtr + "<" + getParentName() + "> operator->() const;");

            mc.cpp.beginFunction("" + dataClassPtr + "<" + getParentName() + "> " + getCppName() + "::operator->() const");
            mc.cpp.addLine("if (" + getParentVariableName() + ")");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return " + getParentVariableName() + ";");
            mc.cpp.decreaseIndent();
            mc.cpp.addLine("throw EXCEPTION(\"Value is missing\");");
            mc.cpp.endFunction();
        }
    }

    // protected
    if (!contains.empty())
    {
        mc.hpp.addLine();
        mc.hpp.addLineNoSpace("protected:");

        // init children
        {
            for (auto t : contains)
            {
                mc.hpp.addLine("template <class T, class... Args>");
                mc.hpp.beginFunction("void init" + t->getChildArrayName(t->getCppName()) + "(Args&&... args)");
                mc.hpp.addLine("for (auto &v : " + t->getChildVariableArrayName(t->getCppName()) + ")");
                mc.hpp.beginBlock();
                if (t->isProxy)
                    mc.hpp.addLine("auto p = v->" + t->getChildVariableName(t->getCppName()) + ".get();");
                else
                    mc.hpp.addLine("auto p = v.second.get();");
                mc.hpp.addLine("p->replace<T>(p, std::forward<Args>(args)...);");
                mc.hpp.endBlock();
                mc.hpp.endFunction();
            }
        }
    }
    else
        mc.hpp.addLine();

    // private
    mc.hpp.addLineNoSpace("private:");

    // copyFrom()
    {
        mc.hpp.addLine("void copyFrom(const " + getCppName() + " &rhs);");

        mc.cpp.beginFunction("void " + getCppName() + "::copyFrom(const " + getCppName() + " &rhs)");
        for (auto &c : columns)
            mc.cpp.addLine(c.second.printVarName() + " = rhs." + c.second.printVarName() + ";");
        mc.cpp.addLine();
        for (auto &c : contains)
            mc.cpp.addLine(c->getChildVariableArrayName(c->getVariableArrayName()) + " = rhs." + c->getChildVariableArrayName(c->getVariableArrayName()) + ";");
        mc.cpp.endFunction();
    }

    // private
    mc.hpp.addLine();
    mc.hpp.addLineNoSpace("private:");

    // friends
    mc.hpp.addLine("friend class " + storageImpl + ";");
    mc.hpp.addLine("template <class T> friend class CTable;");
    mc.hpp.addLine();

    // static functions & data
    mc.hpp.addLineNoSpace("public:");

    // type
    mc.hpp.addLine("static const EObjectType object_type = EObjectType::" + getCppName() + ";");
    mc.hpp.addLine(string("static const bool has_id = ") + (hasIdField ? "true" : "false") + ";");
    mc.hpp.addLine();

    // getSql()
    {
        mc.hpp.addLine("static const char *getSql();");

        mc.cpp.beginFunction("const char *" + getCppName() + "::getSql()");
        auto sql_ = sql;
        replaceAll(sql_, "\n", " \\\n");
        replaceAll(sql_, "\"", "\\\"");
        mc.cpp.addLine("return");
        mc.cpp.addLine("\" \\");
        mc.cpp.decreaseIndent();
        mc.cpp.addLine(sql_ + " \\");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("\";");
        mc.cpp.endFunction();
    }

    mc.hpp.endBlock(true);
    mc.hpp.addLine();
    return mc;
}

ModuleContext Table::printIo() const
{
    ModuleContext mc;
    const auto cols = mapToSet(columns);

    mc.hpp.increaseIndent();

    // printLoad()
    {
        mc.hpp.addLine("void _load" + name + "();");

        mc.cpp.beginFunction("void " + storageImpl + "::_load" + name + "()");
        mc.cpp.addLine("int ret = 0;");
        mc.cpp.addLine("const std::string query = \"select * from " + name + ";\"" + ";");
        mc.cpp.addLine("auto db3 = db->getDb();");
        mc.cpp.addLine("sqlite3_stmt *stmt;");
        mc.cpp.addLine("ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);");
        mc.cpp.addLine("while (sqlite3_step(stmt) == SQLITE_ROW)");
        mc.cpp.beginBlock();
        mc.cpp.addLine("auto v = " + getVariableArrayName() + ".create();");
        for (auto &col : cols)
            mc.cpp.addLine(col.printLoadSqlite3("v") + ";");
        mc.cpp.addLine(getVariableArrayName() + ".insert(v);");
        mc.cpp.endBlock();
        mc.cpp.addLine("ret = sqlite3_finalize(stmt);");
        mc.cpp.endFunction();
    }

    // printLoadPtrs()
    {
        mc.hpp.addLine("void _load" + name + "Ptrs();");

        mc.cpp.beginFunction("void " + storageImpl + "::_load" + name + "Ptrs()");
        if (!fks.empty())
        {
            mc.cpp.addLine("for (auto &" + getVariableName() + " : " + getVariableArrayName() + ")");
            mc.cpp.beginBlock();
            for (auto &col : cols)
            {
                string name = getCppName();
                string var = getVariableName();
                auto fk = col.getFk();
                if (fk)
                {
                    string name2 = toVarName(fk->table_name);
                    mc.cpp.addLine("if (" + name2 + ".find(" + var + "->" + col.getCleanName() + idAccess + ") != " + name2 + ".end())");
                    mc.cpp.increaseIndent();
                    mc.cpp.addLine(var + "->" + col.getCleanName() + " = " +
                        name2 + "[" + var + "->" + col.getCleanName() + idAccess + "];");
                    mc.cpp.decreaseIndent();
                }
            }
            mc.cpp.endBlock();
        }
        mc.cpp.endFunction();
    }

    // printLoadArrays()
    {
        mc.hpp.addLine("void _load" + name + "Arrays();");

        mc.cpp.beginFunction("void " + storageImpl + "::_load" + name + "Arrays()");
        if (container)
        {
            mc.cpp.beginBlock("for (auto &" + getVariableName() + " : " + getVariableArrayName() + ")");
            for (auto &table : contains)
            {
                mc.cpp.addLine("for (auto &" + table->getVariableName() + " : " + table->getVariableArrayName() + ")");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("if (" + getVariableName() + ".first == " + table->getVariableName() + "->" + getVariableName() + idAccess + ")");
                mc.cpp.increaseIndent();
                mc.cpp.addLine(getVariableName() + "->" + table->getChildVariableArrayName(table->getParentName()) + ".insert(" + table->getVariableName() + ");");
                mc.cpp.decreaseIndent();
                mc.cpp.decreaseIndent();
            }
            mc.cpp.endBlock();
        }
        mc.cpp.endFunction();
    }

    // printSave()
    {
        mc.hpp.addLine("void _save" + name + "() const;");

        mc.cpp.beginFunction("void " + storageImpl + "::_save" + name + "() const");
        mc.cpp.addLine("db->execute(\"BEGIN;\");");
        mc.cpp.addLine("db->execute(\"delete from " + name + ";\");");
        mc.cpp.addNoNewLine("const std::string query = \"insert into " + name + " values (");
        for (int i = 0; i < columns.size(); i++)
            mc.cpp.addText("?, ");
        mc.cpp.trimEnd(2);
        mc.cpp.addLineNoSpace(");\";");
        mc.cpp.addLine("int ret = 0;");
        mc.cpp.addLine("auto db3 = db->getDb();");
        mc.cpp.addLine("sqlite3_stmt *stmt;");
        mc.cpp.addLine("ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);");
        mc.cpp.beginBlock("for (auto &" + getVariableName() + " : " + toVarName(name) + ")");
        mc.cpp.addLine("auto &v = " + getVariableName() + (hasIdField ? ".second" : "") + ";");
        for (auto &col : cols)
            mc.cpp.addLine("ret = " + col.printSaveSqlite3("v") + ";");
        mc.cpp.addLine("ret = sqlite3_step(stmt);");
        mc.cpp.addLine("ret = sqlite3_reset(stmt);");
        mc.cpp.endBlock();
        mc.cpp.addLine("ret = sqlite3_finalize(stmt);");
        mc.cpp.addLine("db->execute(\"COMMIT;\");");
        mc.cpp.endFunction();
    }

    return mc;
}

ModuleContext Table::printAddDeleteRecordVirtual() const
{
    string param;
    string param_name;
    if (hasParent)
    {
        param_name = "parent";
        param = "" + iObject + " *" + param_name + " = nullptr";
    }
    ModuleContext mc;
    mc.hpp.increaseIndent();
    mc.hpp.addLine("virtual " + dataClassPtr + "<" + getCppName() + "> add" + getCppName() + "(" + param + ") = 0;");
    mc.hpp.addLine("virtual void delete" + getCppName() + "(" + iObject + " *object) = 0;");
    mc.hpp.decreaseIndent();
    return mc;
}

ModuleContext Table::printAddDeleteRecord() const
{
    ModuleContext mc;
    mc.hpp.increaseIndent();

    string param, param_h;
    string param_name;

    if (hasParent)
    {
        param_name = "parent";
        param_h = "" + iObject + " *" + param_name + " = nullptr";
        param = "" + iObject + " *" + param_name;
    }

    // add record
    {
        mc.hpp.addLine("virtual " + dataClassPtr + "<" + getCppName() + "> add" + getCppName() + "(" + param_h + ") override;");

        mc.cpp.beginFunction("" + dataClassPtr + "<" + getCppName() + "> " + storageImpl + "::add" + getCppName() + "(" + param + ")");
        if (isMapTable)
        {
            string var = getParentVariableName();
            mc.cpp.addLine("auto v = " + getVariableArrayName() + ".createAtEnd();");
            mc.cpp.addLine(getParentName() + " *" + var + " = (" + getParentName() + " *)" + param_name + ";");
            mc.cpp.addLine(var + "->" + getChildVariableArrayName(getParentName()) + ".insert(v);");
            //mc.cpp.addLine(var + idAccess + " = " + var + "->id;");
            mc.cpp.addLine("v->" + var + " = " + var + "s[" + var + "->id];");
            mc.cpp.addLine("return v;");
        }
        else
        {
            if (hasIdField || !hasParent)
            {
                mc.cpp.addLine("return " + getVariableArrayName() + ".createAtEnd();");
            }
            else
            {
                string var = getParentVariableName();
                mc.cpp.addLine("auto v = " + getVariableArrayName() + ".createAtEnd();");
                mc.cpp.addLine(getParentName() + " *" + var + " = (" + getParentName() + " *)" + param_name + ";");
                mc.cpp.addLine(var + "->" + getChildVariableArrayName(getParentName()) + ".insert(v);");
                //mc.cpp.addLine(var + idAccess + " = " + var + "->id;");
                mc.cpp.addLine("v->" + var + " = " + getParentVariableArrayName() + "[" + var + "->id];");
                mc.cpp.addLine("return v;");
            }
        }
        mc.cpp.endFunction();
    }

    // delete record
    {
        mc.hpp.addLine("virtual void delete" + getCppName() + "(" + iObject + " *object) override;");

        mc.cpp.beginFunction("void " + storageImpl + "::delete" + getCppName() + "(" + iObject + " *v)");
        if (container || hasIdField)
            mc.cpp.addLine(getVariableArrayName() + ".erase(v->id);");
        else
            mc.cpp.addLine(getVariableArrayName() + ".erase(v->id);");
            //mc.cpp.addLine(getVariableArrayName() + ".erase(v);");
        mc.cpp.endFunction();
    }

    return mc;
}

ModuleContext Database::printObjectTypes()
{
    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginNamespace("polygon4");
    mc.hpp.beginNamespace("detail");
    mc.hpp.beginBlock("enum class EObjectType : int");
    mc.hpp.addLine("None,");
    mc.hpp.addLine();
    for (auto &table : tables)
        mc.hpp.addLine(table.second.getCppName() + ",");
    mc.hpp.addLine();
    mc.hpp.addLine(anyType + ",");
    mc.hpp.endBlock(true);
    mc.hpp.addLine();
    mc.hpp.endNamespace();
    mc.hpp.addLine();
    mc.hpp.endNamespace();
    return mc;
}

ModuleContext Database::printObjectInterfaces()
{
    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginNamespace("polygon4");
    for (auto &t : tables)
    {
        auto name = t.second.getCppName();
        auto nameUpper = name;
        std::transform(name.begin(), name.end(), nameUpper.begin(), ::toupper);
        mc.hpp.addLineNoSpace("#ifndef POLYGON4_" + nameUpper + "_INTERFACE");
        mc.hpp.addLineNoSpace("DECLARE_INTERFACE_STUB(" + name + ");");
        mc.hpp.addLineNoSpace("#endif");
        mc.hpp.addLine();
    }
    mc.hpp.endNamespace();
    return mc;
}

ModuleContext Database::printTypes()
{
    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.addLine("#include \"../Table.h\"");
    mc.hpp.addLine("#include \"../Types.h\"");
    mc.hpp.addLine();
    mc.hpp.beginNamespace("polygon4");
    mc.hpp.beginNamespace("detail");
    for (auto &table : tables)
        mc.hpp.addLine("class " + table.second.getCppName() + ";");
    mc.hpp.addLine();

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();
    for (auto &table : tables)
        mc += table.second.print();

    mc.hpp.endNamespace();
    mc.hpp.addLine();
    mc.hpp.endNamespace();
    return mc;
}

ModuleContext Database::printStorage()
{
    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.addLine("#include \"../Table.h\"");
    mc.hpp.addLine();
    mc.hpp.beginBlock("class Storage");
    mc.hpp.addLineNoSpace("public:");
    for (auto &table : tables)
        mc.hpp.addLine(arrayType + "<" + table.second.getCppName() + "> " + table.second.getVariableArrayName() + ";");
    mc.hpp.addLine();
    mc.hpp.addLineNoSpace("public:");
    mc.hpp.addLine("Storage();");
    mc.hpp.addLine("virtual ~Storage();");
    mc.hpp.addLine();
    mc.hpp.addLine("virtual void create() const = 0;");
    mc.hpp.addLine("virtual void clear() = 0;");
    mc.hpp.addLine("virtual void load(ProgressCallback callback = ProgressCallback()) = 0;");
    mc.hpp.addLine("virtual void save(ProgressCallback callback = ProgressCallback()) const = 0;");
    mc.hpp.addLine();
    mc.hpp.ifdef("USE_QT");
    mc.hpp.addLine("virtual void printQtTreeView(QTreeWidgetItem *root) const = 0;");
    mc.hpp.addLine("virtual QTreeWidgetItem *addRecord(QTreeWidgetItem *item) = 0;");
    mc.hpp.addLine("virtual void deleteRecord(QTreeWidgetItem *item) = 0;");
    mc.hpp.endif();
    mc.hpp.ifdef("USE_UNREAL_EDITOR");
    mc.hpp.addLine("virtual UE4SPtrTreeViewItem printUE4TreeView() const = 0;");
    mc.hpp.endif();
    mc.hpp.addLine();
    mc.hpp.addLine("virtual OrderedObjectMap getOrderedMap(EObjectType type, std::function<bool(" + iObject + " *)> f = std::function<bool(" + iObject + " *)>()) const = 0;");
    mc.hpp.addLine();

    // printAddDeleteRecordVirtual()
    {
        for (auto &table : tables)
            mc += table.second.printAddDeleteRecordVirtual();
        mc.hpp.addLine();
        mc.hpp.addLine("virtual " + dataClassPtr + "<" + iObject + "> addRecord(" + iObject + " *parent = nullptr) = 0;");
        mc.hpp.addLine("virtual void deleteRecord(" + iObject + " *data) = 0;");
    }
    mc.hpp.endBlock(true);

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();
    mc.cpp.beginFunction("Storage::Storage()");
    for (auto &table : tables)
        mc.cpp.addLine(table.second.getVariableArrayName() + ".setName(\"" + table.second.getCppName() + "\");");
    mc.cpp.endFunction();
    mc.cpp.beginFunction("Storage::~Storage()");
    mc.cpp.endBlock();
    return mc;
}

ModuleContext Database::printStorageImpl()
{
    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginFunction("class StorageImpl : public Storage");
    mc.hpp.addLineNoSpace("#ifdef USE_QT");
    mc.hpp.addLine("Q_DECLARE_TR_FUNCTIONS(StorageImpl)");
    mc.hpp.addLineNoSpace("#endif");
    mc.hpp.addLine();
    mc.hpp.addLineNoSpace("private:");
    mc.hpp.addLine("std::shared_ptr<Database> db;");
    mc.hpp.addLine();
    mc.hpp.addLineNoSpace("private:");

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();
    for (auto &table : tables)
    {
        mc += table.second.printIo();
        mc.hpp.addLine();
    }

    mc.hpp.addLineNoSpace("public:");
    mc.hpp.addLine("StorageImpl(std::shared_ptr<Database> db) : db(db) {}");
    mc.hpp.addLine();
    mc.hpp.addLine("void setDb(std::shared_ptr<Database> db) { this->db = db; }");
    mc.hpp.addLine();

    // create()
    {
        mc.hpp.addLine("virtual void create() const override;");

        mc.cpp.beginFunction("void " + storageImpl + "::create() const");
        for (auto &table : tables)
            mc.cpp.addLine("db->execute(" + table.second.getCppName() + "::getSql()" + ");");
        mc.cpp.endFunction();
    }

    // clear()
    {
        mc.hpp.addLine("virtual void clear() override;");

        mc.cpp.beginFunction("void " + storageImpl + "::clear()");
        for (auto &table : tables)
            mc.cpp.addLine(table.second.getVariableArrayName() + ".clear();");
        mc.cpp.endFunction();
    }

    // load()
    {
        double step = 100.0 / (tables.size() * 3.0);
        double progress = 0;

        mc.hpp.addLine("virtual void load(ProgressCallback callback = ProgressCallback()) override;");

        mc.cpp.beginFunction("void " + storageImpl + "::load(ProgressCallback callback)");
        for (auto &table : tables)
        {
            mc.cpp.addLine("_load" + table.first + "();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + to_string(progress += step) + ");");
        }
        mc.cpp.addLine();
        for (auto &table : tables)
        {
            mc.cpp.addLine("_load" + table.first + "Ptrs();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + to_string(progress += step) + ");");
        }
        mc.cpp.addLine();
        for (auto &table : tables)
        {
            mc.cpp.addLine("_load" + table.first + "Arrays();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + to_string(progress += step) + ");");
        }
        mc.cpp.endFunction();
    }

    // save()
    {
        double step = 100.0 / tables.size();
        double progress = 0;

        mc.hpp.addLine("virtual void save(ProgressCallback callback = ProgressCallback()) const override;");

        mc.cpp.beginFunction("void " + storageImpl + "::save(ProgressCallback callback) const");
        for (auto &table : tables)
        {
            mc.cpp.addLine("_save" + table.first + "();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + to_string(progress += step) + ");");
        }
        mc.cpp.endFunction();
    }

    // printAddDeleteRecord()
    {
        mc.hpp.addLine();
        for (auto &table : tables)
            mc += table.second.printAddDeleteRecord();
        mc.hpp.addLine();

        // addRecord()
        {
            mc.hpp.addLine("virtual " + dataClassPtr + "<" + iObject + "> addRecord(" + iObject + " *parent = nullptr) override;");

            mc.cpp.beginFunction("" + dataClassPtr + "<" + iObject + "> " + storageImpl + "::addRecord(" + iObject + " *parent)");
            mc.cpp.addLine("" + dataClassPtr + "<" + iObject + "> p;");
            mc.cpp.addLine("EObjectType type = parent->getType();");
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &table : tables)
            {
                mc.cpp.addLine("case EObjectType::" + table.second.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("p = add" + table.second.getCppName() + "(" + (table.second.hasParentTable() ? "parent" : "") + ");");
                mc.cpp.addLine("break;");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.addLine("return p;");
            mc.cpp.endFunction();
        }

        // deleteRecord()
        {
            mc.hpp.addLine("virtual void deleteRecord(" + iObject + " *data) override;");

            mc.cpp.beginFunction("void " + storageImpl + "::deleteRecord(" + iObject + " *data)");
            mc.cpp.addLine("EObjectType type = data->getType();");
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &table : tables)
            {
                mc.cpp.addLine("case EObjectType::" + table.second.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("delete" + table.second.getCppName() + "(data);");
                mc.cpp.addLine("break;");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.endFunction();
        }
    }

    // printQtTreeView()
    {
        mc.hpp.addLine();
        mc.hpp.addLineNoSpace("#ifdef USE_QT");
        mc.cpp.addLineNoSpace("#ifdef USE_QT");

        // printQtTreeView()
        {
            mc.hpp.addLine("virtual void printQtTreeView(QTreeWidgetItem *root) const override;");

            mc.cpp.beginFunction("void " + storageImpl + "::printQtTreeView(QTreeWidgetItem *root) const");
            mc.cpp.addLine("QTreeWidgetItem *item;");
            for (auto &table : tables)
            {
                if (!table.second.isVisibleInTreeView())
                    continue;
                mc.cpp.addLine();
                mc.cpp.addLine("item = new QTreeWidgetItem(root, QStringList(" + tr(splitWords(table.second.getName())) + "));");
                mc.cpp.addLine("item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::" + table.second.getCppName() + "));");
                mc.cpp.addLine("auto " + table.second.getVariableArrayName() + " = getOrderedMap(EObjectType::" + table.second.getCppName() + ");");
                mc.cpp.addLine("for (auto &v : " + table.second.getVariableArrayName() + ")");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("v.second->printQtTreeView(item);");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.endFunction();
        }

        // addRecord()
        {
            mc.hpp.addLine("virtual QTreeWidgetItem *addRecord(QTreeWidgetItem *item) override;");

            mc.cpp.beginFunction("QTreeWidgetItem *" + storageImpl + "::addRecord(QTreeWidgetItem *item)");
            mc.cpp.addLine("EObjectType type = static_cast<EObjectType>(item->data(0, Qt::UserRole).toInt());");
            mc.cpp.addLine("" + iObject + " *parent = nullptr;");
            mc.cpp.addLine("auto parentItem = item->parent();");
            mc.cpp.addLine("if (parentItem)");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("parent = (" + iObject + " *)parentItem->data(0, Qt::UserRole).toULongLong();");
            mc.cpp.decreaseIndent();
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &table : tables)
            {
                mc.cpp.addLine("case EObjectType::" + table.second.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("return add" + table.second.getCppName() + "(" + (table.second.hasParentTable() ? "parent" : "") + ")->printQtTreeView(item);");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return 0;");
            mc.cpp.endBlock();
            mc.cpp.endFunction();
        }

        // deleteRecord()
        {
            mc.hpp.addLine("virtual void deleteRecord(QTreeWidgetItem *item) override;");

            mc.cpp.beginFunction("void " + storageImpl + "::deleteRecord(QTreeWidgetItem *item)");
            mc.cpp.addLine("auto data = (" + iObject + " *)item->data(0, Qt::UserRole).toULongLong();");
            mc.cpp.addLine("EObjectType type = data->getType();");
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &table : tables)
            {
                mc.cpp.addLine("case EObjectType::" + table.second.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("delete" + table.second.getCppName() + "(data);");
                mc.cpp.addLine("break;");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.addLine("item->parent()->removeChild(item);");
            mc.cpp.endBlock();
        }

        mc.hpp.addLineNoSpace("#endif");
        mc.cpp.addLineNoSpace("#endif");
    }

    // printUE4TreeView()
    {
        mc.hpp.addLine();
        mc.hpp.ifdef("USE_UNREAL_EDITOR");

        // printUE4TreeView()
        {
            mc.hpp.beginFunction("virtual UE4SPtrTreeViewItem printUE4TreeView() const override");
            mc.hpp.addLine("UE4SPtrTreeViewItem root = MakeShareable(new UE4TreeViewItem);");
            mc.hpp.addLine("UE4SPtrTreeViewItem item;");
            for (auto &table : tables)
            {
                if (!table.second.isVisibleInTreeView())
                    continue;
                mc.hpp.addLine();
                mc.hpp.addLine("item = MakeShareable(new UE4TreeViewItem);");
                mc.hpp.addLine("root->Children.Add(item);");
                mc.hpp.addLine("item->Name = " + trUE4(splitWords(table.second.getName())) + ";");
                mc.hpp.addLine("item->Type = EObjectType::" + table.second.getCppName() + ";");
                mc.hpp.addLine("auto " + table.second.getVariableArrayName() + " = getOrderedMap(EObjectType::" + table.second.getCppName() + ");");
                mc.hpp.addLine("for (auto &v : " + table.second.getVariableArrayName() + ")");
                mc.hpp.increaseIndent();
                mc.hpp.addLine("item->Children.Add(v.second->printUE4TreeView());");
                mc.hpp.decreaseIndent();
            }
            mc.hpp.addLine("return root;");
            mc.hpp.endFunction();
        }

        /*// addRecord()
        {
            mc.hpp.addLine("virtual QTreeWidgetItem *addRecord(QTreeWidgetItem *item) override;");

            mc.cpp.beginFunction("QTreeWidgetItem *" + storageImpl + "::addRecord(QTreeWidgetItem *item)");
            mc.cpp.addLine("EObjectType type = static_cast<EObjectType>(item->data(0, Qt::UserRole).toInt());");
            mc.cpp.addLine("" + iObject + " *parent = nullptr;");
            mc.cpp.addLine("auto parentItem = item->parent();");
            mc.cpp.addLine("if (parentItem)");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("parent = (" + iObject + " *)parentItem->data(0, Qt::UserRole).toULongLong();");
            mc.cpp.decreaseIndent();
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &table : tables)
            {
                mc.cpp.addLine("case EObjectType::" + table.second.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("return add" + table.second.getCppName() + "(" + (table.second.hasParentTable() ? "parent" : "") + ")->printQtTreeView(item);");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return 0;");
            mc.cpp.endBlock();
            mc.cpp.endFunction();
        }

        // deleteRecord()
        {
            mc.hpp.addLine("virtual void deleteRecord(QTreeWidgetItem *item) override;");

            mc.cpp.beginFunction("void " + storageImpl + "::deleteRecord(QTreeWidgetItem *item)");
            mc.cpp.addLine("auto data = (" + iObject + " *)item->data(0, Qt::UserRole).toULongLong();");
            mc.cpp.addLine("EObjectType type = data->getType();");
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &table : tables)
            {
                mc.cpp.addLine("case EObjectType::" + table.second.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("delete" + table.second.getCppName() + "(data);");
                mc.cpp.addLine("break;");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.addLine("item->parent()->removeChild(item);");
            mc.cpp.endBlock();
        }*/

        mc.hpp.endif();
    }

    // printGetOrderedMap()
    {
        mc.hpp.addLine();
        mc.hpp.addLine("virtual OrderedObjectMap getOrderedMap(EObjectType type, std::function<bool(" + iObject + " *)> f = std::function<bool(" + iObject + " *)>()) const override;");

        mc.cpp.addLine();
        mc.cpp.beginFunction("OrderedObjectMap " + storageImpl + "::getOrderedMap(EObjectType type, std::function<bool(" + iObject + " *)> f) const");
        mc.cpp.beginBlock("switch (type)", false);
        for (auto &table : tables)
        {
            mc.cpp.addLine("case EObjectType::" + table.second.getCppName() + ":");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return ::getOrderedMap(" + table.second.getVariableArrayName() + ", f);");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("return OrderedObjectMap();");
        mc.cpp.endBlock();
        mc.cpp.endFunction();
    }

    mc.hpp.endBlock(true);
    return mc;
}

ModuleContext Database::printHelpers()
{
    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();
    
    // getTableType()
    {
        mc.hpp.addLine("EObjectType getTableType(const std::string &table);");

        mc.cpp.beginFunction("EObjectType getTableType(const std::string &table)");
        mc.cpp.addLine("static std::map<std::string, EObjectType> types =");
        mc.cpp.beginBlock();
        for (auto &table : tables)
            mc.cpp.addLine("{ \"" + table.second.getName() + "\", EObjectType::" + table.second.getCppName() + " },");
        mc.cpp.addLine("{ \"" + anyTable + "\", EObjectType::" + anyType + " },");
        mc.cpp.endBlock(true);
        mc.cpp.addLine("return types[table];");
        mc.cpp.endFunction();
    }

    // getTableNameByType()
    {
        mc.hpp.addLine("std::string getTableNameByType(EObjectType type);");

        mc.cpp.beginFunction("std::string getTableNameByType(EObjectType type)");
        mc.cpp.addLine("static std::map<EObjectType, std::string> tables =");
        mc.cpp.beginBlock();
        for (auto &table : tables)
            mc.cpp.addLine("{ EObjectType::" + table.second.getCppName() + ", \"" + table.second.getName() + "\" },");
        mc.cpp.addLine("{ EObjectType::" + anyType + ", \"" + anyTable + "\" },");
        mc.cpp.endBlock(true);
        mc.cpp.addLine("return tables[type];");
        mc.cpp.endFunction();
    }
    
    // qt
    {
        mc.hpp.addLineNoSpace("#ifdef USE_QT");
        mc.cpp.addLineNoSpace("#ifdef USE_QT");

        // retranslateFieldNames()
        {
            mc.hpp.addLine("void retranslateFieldNames();");

            mc.cpp.addLine("typedef std::map<std::string, QString> FieldNames;");
            mc.cpp.addLine();
            mc.cpp.addLine("FieldNames fieldNames;");
            mc.cpp.addLine();
            mc.cpp.beginFunction("void retranslateFieldNames()");
            mc.cpp.addLine("FieldNames names =");
            mc.cpp.beginBlock();
            set<string> fields;
            for (auto &table : tables)
                for (auto &col : table.second.getColumns())
                    fields.insert(col.second.getName());
            for (auto &f : fields)
                mc.cpp.addLine("{ \"" + f + "\", " + tr(f) + " },");
            mc.cpp.endBlock(true);
            mc.cpp.addLine("fieldNames = names;");
            mc.cpp.endFunction();
        }

        // getFieldName()
        {
            mc.hpp.addLine("QString getFieldName(const std::string &name);");

            mc.cpp.beginFunction("QString getFieldName(const std::string &name)");
            mc.cpp.addLine("return fieldNames[name];");
            mc.cpp.endFunction();
        }
        
        // retranslateTableNames()
        {
            mc.hpp.addLine("void retranslateTableNames();");

            mc.cpp.addLine("typedef std::map<std::string, QString> TableNames;");
            mc.cpp.addLine();
            mc.cpp.addLine("TableNames tableNames;");
            mc.cpp.addLine();
            mc.cpp.beginFunction("void retranslateTableNames()");
            mc.cpp.addLine("TableNames names =");
            mc.cpp.beginBlock();
            for (auto &t : tables)
                mc.cpp.addLine("{ \"" + t.second.getName() + "\", " + tr(splitWords(t.second.getName())) + " },");
            mc.cpp.addLine("{ \"" + anyTable + "\", " + tr(splitWords(anyTable)) + " },");
            mc.cpp.endBlock(true);
            mc.cpp.addLine("tableNames = names;");
            mc.cpp.endFunction();
        }

        // getTableName()
        {
            mc.hpp.addLine("QString getTableName(const std::string &name);");

            mc.cpp.beginFunction("QString getTableName(const std::string &name)");
            mc.cpp.addLine("return tableNames[name];");
            mc.cpp.endFunction();
        }

        mc.hpp.addLineNoSpace("#endif");
        mc.cpp.addLineNoSpace("#endif");
    }

    return mc;
}

void Database::init()
{
    for (auto &table : tables)
        table.second.init(tables);
}
