#include "data.h"

#include <algorithm>

const std::string autogenerated_warning = "/* DO NOT EDIT! This is an autogenerated file. */\n\n";

const string space = "    ";
const string String = "String";
const string TextType = "Text";
const string storageImpl = "StorageImpl";

const set<string> mapTables =
{
    "MapBuilding",
    "MapObject",
    "QuestReward"
};

const set<string> removeFromAddRecord = 
{
    "MechanoidGroups",
    "ScriptVariables",
};

const set<string> containers = 
{
    "Configuration",
    "MapBuilding",
    "QuestReward",
    "Modification",
    "MechanoidGroup",
    "Clan",
    "Save",
};

const multimap<string, string> containers1n = 
{
    { "Map", "MapBuilding" },
    { "Map", "MapObject" },
    { "Save", "ScriptVariable" },
    { "Quest", "QuestReward" },
};

// these objects are shown in tree view
const set<string> treeViewItems = 
{
    "Buildings",
    "Clans",
    "Configurations",
    "Coordinates",
    "Equipments",
    "Gliders",
    "Goods",
    "Maps",
    "Mechanoids",
    "Modifications",
    "Modificators",
    "Objects",
    "Players",
    "Projectiles",
    "Quests",
    "Saves",
    "Strings",
    "Weapons",
};

const map<string, string> objectNames = 
{
    { "Players", "to_string(mechanoid)" },
    { "ScriptVariables", "variable" },
    { "ClanReputations", "clan.id < clan2.id ? (to_string(clan).wstring() + L\" - \" + to_string(clan2).wstring()) : (to_string(clan2).wstring() + L\" - \" + to_string(clan).wstring())" },
    { "MapBuildings", "to_string(building)" },
    { "Coordinates", "to_string(*this)" },
    { "QuestRewards", "to_string(quest)" }
};

bool replaceAll(std::string &str, const std::string &from, const std::string &to)
{
    bool replaced = false;
    size_t start_pos = 0;
    while ((start_pos = str.find(from, start_pos)) != std::string::npos)
    {
         str.replace(start_pos, from.length(), to);
         start_pos += to.length();
         replaced = true;
    }
    return replaced;
}

string getTableName(string s)
{
    if (s.empty())
        return s;
    if (s[s.size() - 1] == 's')
        s = s.substr(0, s.size() - 1);
    return s;
}

string removeId(string s)
{
    replaceAll(s, "_id", "");
    return s;
}

string toVarName(string s)
{
    s[0] = tolower(s[0]);
    return s;
}

string splitWords(string s)
{
    string r;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (isupper(s[i]) && i)
            r += " ";
        r += s[i];
    }
    return r;
}

string getParentType(string s)
{
    string p = splitWords(s);
    p = p.substr(0, p.rfind(' '));
    replaceAll(p, " ", "");
    return p;
}

bool isMapTable(string name)
{
    return mapTables.find(name) != mapTables.end();
}

string tr(string s)
{
    return "QCoreApplication::translate(\"DB\", \"" + s + "\")";
}

string inheritQObject()
{
    string s;
    //s += "#ifdef USE_QT\n";
    //s += space + ": public QObject\n";
    //s += "#endif\n";
    return s;
}

string declareQObject()
{
    string s;
    //s += "#ifdef USE_QT\n";
    //s += space + "Q_OBJECT\n";
    //s += "#endif\n\n";
    s += "public:\n";
    return s;
}

template<typename T, typename K>
set<T> mapToSet(const map<K, T> &map)
{
    set<T> s;
    for (auto &v : map)
        s.insert(v.second);
    return s;
}

string Column::printVar() const
{
    string s;
    if (fk)
    {
        s += "IdPtr<" + getTableName(fk->table_name) + "> " + printVarName();
    }
    else
    {
        switch (type)
        {
        case ColumnType::Integer:
            s += "int";
            break;
        case ColumnType::Real:
            s += "float";
            break;
        case ColumnType::Text:
            s += TextType;
            break;
        }
        s += " " + printVarName();
        if (type == ColumnType::Integer || type == ColumnType::Real)
        {
            s += " = ";
            switch (type)
            {
            case ColumnType::Integer:
                s += "0";
                break;
            case ColumnType::Real:
                s += "0.0f";
                break;
            }
        }
    }
    return s;
}

string Column::printVarName() const
{
    string s;
    if (fk)
    {
        s += toVarName(removeId(name));
    }
    else
    {
        s += name;
    }
    return s;
}

string Column::printLoad() const
{
    string s;
    if (fk)
    {
        s += toVarName(removeId(name)) + ".id = std::stoi(cols[" + to_string(id) + "])";
    }
    else
    {
        s += name + " = ";
        switch (type)
        {
        case ColumnType::Integer:
            s += "std::stoi(cols[" + to_string(id) + "])";
            break;
        case ColumnType::Real:
            s += "std::stof(cols[" + to_string(id) + "])";
            break;
        case ColumnType::Text:
            s += "cols[" + to_string(id) + "]";
            break;
        }
    }
    return s;
}

string Column::printSet() const
{
    string s;
    if (fk)
    {
        s += toVarName(removeId(name)) + ".id = std::stoi(text.string())";
    }
    else
    {
        s += name + " = ";
        switch (type)
        {
        case ColumnType::Integer:
            s += "std::stoi(text.string())";
            break;
        case ColumnType::Real:
            s += "std::stof(text.string())";
            break;
        case ColumnType::Text:
            s += "text.string()";
            break;
        }
    }
    return s;
}

string Column::printSetPtr() const
{
    string s;
    if (fk)
    {
        s += toVarName(removeId(name)) + " = std::static_pointer_cast<" + getTableName(fk->table_name) + ">(ptr)";
    }
    return s;
}

string Column::printSave(string var) const
{
    string s;
    if (fk)
    {
        s += "std::to_string(" + var + "->" + removeId(name) + ".id)";
    }
    else
    {
        switch (type)
        {
        case ColumnType::Integer:
        case ColumnType::Real:
            s += "std::to_string(" + var + "->" + name + ")";
            break;
        case ColumnType::Text:
            s += var + "->" + name + ".string()";
            break;
        }
    }
    return s;
}

string Table::printForward() const
{
    string s;
    s += "class " + getTableName(this->name) + ";\n";
    return s;
}

string Table::print(const Tables &tables, string &si) const
{
    string s;
    string name = getTableName(this->name);
    set<Column> cols = mapToSet(columns);
    if (name == String)
    {
        s += "enum class LocalizationType : EnumType\n";
        s += "{\n";
        for (auto i = next(cols.begin()); i != cols.end(); i++)
            s += space + i->name + ",\n";
        s += "\n";
        s += space + "max\n";
        s += "};\n\n";
    }
    s += "class " + name + " : public IObject\n";
    s += "{\n";
    s += declareQObject();
    for (auto &col : cols)
        s += space + col.printVar() + ";\n";
    if (containers.find(name) != containers.end())
    {
        s += "\n";
        for (auto &table : tables)
        {
            if (table.first.find(name) == 0 && isupper(table.first[name.size()]))
            {
                string var = table.first.substr(name.size());
                s += space + "CVector<Ptr<" + getTableName(table.first) + ">> " + toVarName(var) + ";\n";
            }
        }
    }
    auto er = containers1n.equal_range(name);
    bool once = false;
    for (auto iter1n = er.first; iter1n != er.second; iter1n++)
    {
        if (!once)
        {
            s += "\n";
            once = true;
        }
        string var = iter1n->second.substr(iter1n->first.size());
        s += space + "CVector<Ptr<" + getTableName(iter1n->second) + ">> " + toVarName(var) + "s" + ";\n";
    }
    s += "\n";
    
    s += space + "virtual EObjectType getType() const;\n";
    si += "EObjectType " + name + "::getType() const\n";
    si += "{\n";
    si += space + "return EObjectType::" + name + ";\n";
    si += "}\n\n";

    s += space + "virtual Text getVariableString(int columnId) const;\n";
    si += "Text " + name + "::getVariableString(int columnId) const\n";
    si += "{\n";
    {
        si += space + "switch (columnId)\n";
        si += space + "{\n";
        auto cols = mapToSet(columns);
        for (auto &col : cols)
        {
            si += space + "case " + to_string(col.id) + ":\n";
            //if (col.type == ColumnType::Real)
            //{
            //    si += space + ::space + "{ std::stringstream ss; ss << " + col.printVarName() + "; return ss.str(); }\n";
            //    continue;
            //}
            si += space + ::space + "return to_string(" + col.printVarName() + ");\n";
        }
        si += space + "default:\n";
        si += space + ::space + "return \"\";\n";
        si += space + "}\n";
        si += space + "return \"\";\n";
    }
    si += "}\n\n";
    
    s += space + "virtual void setVariableString(int columnId, Text text, Ptr<IObject> ptr = Ptr<IObject>());\n";
    si += "void " + name + "::setVariableString(int columnId, Text text, Ptr<IObject> ptr)\n";
    si += "{\n";
    {
        si += space + "switch (columnId)\n";
        si += space + "{\n";
        auto cols = mapToSet(columns);
        for (auto &col : cols)
        {
            si += space + "case " + to_string(col.id) + ":\n";
            if (col.fk)
                si += space + ::space + col.printSetPtr() + ";\n";
            else
                si += space + ::space + col.printSet() + ";\n";
            si += space + ::space + "break;\n";
        }
        si += space + "default:\n";
        si += space + ::space + "break;\n";
        si += space + "}\n";
    }
    si += "}\n\n";

    s += "#ifdef USE_QT\n";
    s += space + "virtual QTreeWidgetItem *printQtTreeView(QTreeWidgetItem *parent) const;\n";
    s += "#endif\n";
    si += "#ifdef USE_QT\n";
    si += "QTreeWidgetItem *" + name + "::printQtTreeView(QTreeWidgetItem *parent) const\n";
    si += "{\n";
    {
        si += space + "auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));" + "\n";
        si += space + "item->setData(0, Qt::UserRole, (uint64_t)this);" + "\n";
        
        bool once = false;
        if (containers.find(name) != containers.end())
        {
            for (auto &table : tables)
            {
                if (table.first.find(name) == 0 && isupper(table.first[name.size()]))
                {
                    if (!once)
                    {
                        si += space + "QTreeWidgetItem *root;\n";
                        once = true;
                    }
                    si += "\n";
                    string var = table.first.substr(name.size());
                    si += space + "root = new QTreeWidgetItem(item, QStringList(" + tr(splitWords(var)) + "));\n";
                    si += space + "root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::" + getTableName(table.first) + "));" + "\n";
                    si += space + "for (auto &" + getTableName(toVarName(var)) + " : " + toVarName(var) + ")\n";
                    {
                        string space = ::space + ::space;
                        si += space + getTableName(toVarName(var)) + "->" + "printQtTreeView(root);\n";
                    }
                }
            }
        }
        auto er = containers1n.equal_range(name);
        for (auto iter1n = er.first; iter1n != er.second; iter1n++)
        {
            si += "\n";
            if (!once)
            {
                si += space + "QTreeWidgetItem *root;\n\n";
                once = true;
            }
            string var = iter1n->second.substr(iter1n->first.size());
            si += space + "root = new QTreeWidgetItem(item, QStringList(" + tr(splitWords(iter1n->second + "s")) + "));\n";
            si += space + "root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::" + iter1n->second + "));" + "\n";
            si += space + "for (auto &" + toVarName(getTableName(var)) + " : " + toVarName(var) + "s" + ")\n";
            {
                string space = ::space + ::space;
                si += space + toVarName(getTableName(var)) + "->" + "printQtTreeView(root);\n";
            }
        }

        si += "\n";
        si += space + "item->sortChildren(0, Qt::AscendingOrder);\n";
        si += space + "return item;\n";
    }
    si += "}\n";
    si += "#endif\n\n";
    
    if (name != String)
    {
        s += space + "virtual Text getName() const;\n";
        si += "Text " + name + "::getName() const\n";
        si += "{\n";
        si += space + "Text n;\n";
        auto iter_object_name = objectNames.find(this->name);
        if (iter_object_name != objectNames.end())
        {
            si += space + "n = " + iter_object_name->second + ";\n";
            si += space + "if (!n.empty())\n";
            si += space + space + "return n;\n";
        }
        auto iter = find_if(columns.begin(), columns.end(), [](const Columns::value_type &p)
        {
            return p.first.find("name") != -1;
        });
        if (iter != columns.end())
        {
            if (iter->second.type == ColumnType::Text)
                si += space + "n = " + iter->second.printVarName() + ";\n";
            else
                si += space + "n = to_string(" + iter->second.printVarName() + ");\n";
            si += space + "if (!n.empty())\n";
            si += space + space + "return n;\n";
        }
        iter = find_if(columns.begin(), columns.end(), [](const Columns::value_type &p)
        {
            return p.first.find("text") != -1;
        });
        if (iter != columns.end())
        {
            if (iter->second.type == ColumnType::Text)
                si += space + "n = " + iter->second.printVarName() + ";\n";
            else
                si += space + "n = to_string(" + iter->second.printVarName() + ");\n";
            si += space + "if (!n.empty())\n";
            si += space + space + "return n;\n";
        }
        iter = find_if(columns.begin(), columns.end(), [&](const Columns::value_type &p)
        {
            string ptr_type = getParentType(name);
            string var = toVarName(name.substr(ptr_type.size()));
            if (!var.empty())
                return p.first.find(var) != -1;
            return false;
        });
        if (iter != columns.end())
        {
            string ptr_type = getParentType(name);
            string var = toVarName(name.substr(ptr_type.size()));
            si += space + "n = to_string(" + var + ");\n";
            si += space + "if (!n.empty())\n";
            si += space + space + "return n;\n";
        }
        si += space + "return IObject::getName();\n";
        si += "}\n\n";
    }
    else
    {
        s += space + "virtual Text getName() const;\n";
        si += "Text " + name + "::getName() const\n";
        si += "{\n";
        si += space + "auto s = ((Text *)&" + next(cols.begin())->name + ")[gCurrentLocalizationId];" + "\n";
        si += space + "if (!s.empty())" + "\n";
        si += space + space + "return s;\n";
        si += space + "for (int i = 0; i < static_cast<int>(LocalizationType::max); i++)" + "\n";
        si += space + "{" + "\n";
        {
            string space = ::space + ::space;
            si += space + "s = ((Text *)&" + next(cols.begin())->name + ")[i];" + "\n";
            si += space + "if (!s.empty())" + "\n";
            si += space + ::space + "return s;" + "\n";
        }
        si += space + "}" + "\n";
        si += space + "return s;\n";
        si += "}\n\n";
    }
end:

    s += "\n";
    s += space + "bool operator==(const " + getTableName(this->name) + " &rhs) const;\n";
    si += "bool " + getTableName(this->name) + "::operator==(const " + getTableName(this->name) + " &rhs) const\n";
    si += "{\n";
    si += space + "return\n";
    for (auto &col : columns)
        if (col.first != "id")
            si += space + space + col.second.printVarName() + " == rhs." + col.second.printVarName() + " &&\n";
    si += space + space + "1;\n";
    si += "}\n\n";

    s += "};\n\n";
    return s;
}

bool Table::hasIdField() const
{
    auto iter = columns.find("id");
    return iter != columns.end() && iter->second.type == ColumnType::Integer;
}

string Table::printIo(const Tables &tables, string &impl)
{
    string s;
    s += printLoad(impl);
    s += printLoadPtrs(impl);
    s += printLoadArrays(tables, impl);
    s += printSave(impl);
    return s;
}

string Table::printLoad(string &si)
{
    string s;
    s += space + "void _load" + name + "();\n";
    si += "void " + storageImpl + "::_load" + name + "()\n";
    si += "{\n";
    {
        si += space + "auto callback = [](void *o, int ncols, char **cols, char **names)" + "\n";
        si += space + "{" + "\n";
        {
            string space = ::space + ::space;
            set<Column> cols = mapToSet(columns);
            string name = getTableName(this->name);
            string var = toVarName(name);
            si += space + "Ptr<" + name + "> " + var + " = std::make_shared<" + name + ">();" + "\n";
            for (auto &col : cols)
                si += space + "if (cols[" + to_string(col.id) + "]) " + var + "->" + col.printLoad() + ";\n";
            si += "\n";
            si += space + "Storage *storage = (Storage *)o;" + "\n";
            name = toVarName(this->name);
            if (hasIdField())
                si += space + "storage->" + name + "[" + var + "->id] = " + var + ";" + "\n";
            else
                si += space + "storage->" + name + ".push_back(" + var + ");" + "\n";
            si += space + "return 0;" + "\n";
        }
        si += space + "};" + "\n";
        si += space + "db->execute(\"select * from " + name + ";\", this, callback);\n";
    }
    si += "}\n\n";
    return s;
}

string Table::printLoadPtrs(string &si)
{
    string s;
    s += space + "void _load" + name + "Ptrs();\n";
    si += "void " + storageImpl + "::_load" + name + "Ptrs()\n";
    si += "{\n";
    {
        set<Column> cols = mapToSet(columns);
        bool found = false;
        for (auto &col : cols)
        {
            auto iter = fks.find(col.name);
            if (iter != fks.end())
            {
                found = true;
            }
        }
        if (found)
        {
            si += space + "for (auto &" + getTableName(toVarName(name)) + " : " + toVarName(name) + ")\n";
            si += space + "{\n";
            int col_id = 0;
            for (auto &col : cols)
            {
                string space = ::space + ::space;
                string name = getTableName(this->name);
                string var = toVarName(name);
                auto iter = fks.find(col.name);
                if (iter != fks.end())
                {
                    string name2 = toVarName(iter->second.table_name);
                    if (hasIdField())
                    {
                        si += space + "if (" + name2 + ".find(" + getTableName(toVarName(name)) + ".second->" + removeId(col.name) + ".id) != " + name2 + ".end())" + "\n";
                        si += space + ::space + (toVarName(name)) + ".second->" + removeId(col.name) + ".ptr = " +
                            name2 + "[" + getTableName(toVarName(name)) + ".second->" + removeId(col.name) + ".id]";
                        si += ";\n";
                    }
                    else
                    {
                        si += space + "if (" + name2 + ".find(" + getTableName(toVarName(name)) + "->" + removeId(col.name) + ".id) != " + name2 + ".end())" + "\n";
                        si += space + ::space + getTableName(toVarName(name)) + "->" + removeId(col.name) + ".ptr = " +
                            name2 + "[" + getTableName(toVarName(name)) + "->" + removeId(col.name) + ".id]";
                        si += ";\n";
                    }
                }
                col_id++;
            }
            si += space + "}\n";
        }
    }
    si += "}\n\n";
    return s;
}

string Table::printLoadArrays(const Tables &tables, string &si)
{
    string s;
    s += space + "void _load" + name + "Arrays();\n";
    si += "void " + storageImpl + "::_load" + name + "Arrays()\n";
    si += "{\n";
    {
        string name = getTableName(this->name);
        set<Column> cols = mapToSet(columns);
        bool once = false;
        if (containers.find(name) != containers.end())
        {
            for (auto &table : tables)
            {
                if (table.first.find(name) == 0 && isupper(table.first[name.size()]))
                {
                    if (!once)
                    {
                        si += space + "for (auto &" + toVarName(getTableName(this->name)) + " : " + toVarName(this->name) + ")" + "\n";
                        si += space + "{\n";
                        once = true;
                    }
                    {
                        string space = ::space + ::space;
                        string var = table.first.substr(name.size());
                        si += space + "for (auto &" + toVarName(getTableName(table.first)) + " : " + toVarName(table.first) + ")\n";
                        {
                            string space = ::space + ::space + ::space;
                            si += space + "if (" + toVarName(getTableName(this->name)) + ".first == " + 
                                toVarName(getTableName(table.first)) + "->" + toVarName(getTableName(this->name)) + ".id)\n";
                            {
                                string space = ::space + ::space + ::space + ::space;
                                si += space + toVarName(getTableName(this->name)) + ".second->" + toVarName(var) + ".push_back(" + toVarName(getTableName(table.first)) + ");\n";
                            }
                        }
                    }
                }
            }
        }
        auto er = containers1n.equal_range(name);
        for (auto iter1n = er.first; iter1n != er.second; iter1n++)
        {
            if (!once)
            {
                si += space + "for (auto &" + toVarName(getTableName(this->name)) + " : " + toVarName(this->name) + ")" + "\n";
                si += space + "{\n";
                once = true;
            }
            string space = ::space + ::space;
            string var = iter1n->second.substr(iter1n->first.size());
            si += space + "for (auto &" + toVarName(iter1n->second) + " : " + toVarName(iter1n->second) + "s" + ")\n";
            {
                string space = ::space + ::space + ::space;
                si += space + "if (" + toVarName(getTableName(this->name)) + ".first == " + 
                    toVarName(getTableName(iter1n->second)) + (isMapTable(iter1n->second) ? ".second" : "") + "->" + toVarName(getTableName(this->name)) + ".id)\n";
                {
                    string space = ::space + ::space + ::space + ::space;
                    si += space + toVarName(getTableName(this->name)) + ".second->" + toVarName(var) + "s" +
                        ".push_back(" + toVarName(getTableName(iter1n->second)) + (isMapTable(iter1n->second) ? ".second" : "") + ");\n";
                }
            }
        }
        if (once)
        {
            si += space + "}\n";
        }
    }
    si += "}\n\n";
    return s;
}

string Table::printSave(string &si)
{
    string s;
    s += space + "void _save" + name + "();\n";
    si += "void " + storageImpl + "::_save" + name + "()\n";
    si += "{\n";
    {
        si += space + "std::string query;" + "\n";
        si += space + "query += \"delete from " + name + ";\"" + ";\n";
        si += space + "db->execute(query.c_str(), 0, 0);\n";
        si += space + "query.clear();\n";
        si += space + "if (" + toVarName(name) + ".empty())" + "\n";
        si += space + ::space + "return;\n";
        si += space + "query += \"insert or replace into " + name + " values\\n\"" + ";\n";
        si += space + "for (auto &" + toVarName(getTableName(name)) + " : " + toVarName(name) + ")" + "\n";
        si += space + "{\n";
        {
            string space = ::space + ::space;
            si += space + "query += \"(\";\n";
            auto cols = mapToSet(columns);
            for (auto &col : cols)
                si += space + "query += \"'\" + " + col.printSave(toVarName(getTableName(name)) + (hasIdField() ? ".second" : "")) + " + \"',\";\n";
            si += space + "query.resize(query.size() - 1);\n";
            si += space + "query += \"),\\n\";\n";
        }
        si += space + "}\n";
        si += space + "query.resize(query.size() - 2);\n";
        si += space + "query += \";\";\n";
        si += space + "db->execute(query.c_str(), 0, 0);\n";
    }
    si += "}\n\n";
    return s;
}

string Table::printUsing()
{
    string s;
    s += "using detail::" + getTableName(this->name) + ";\n";
    return s;
}

void Database::assignFks()
{
    for (auto &table : tables)
    {
        for (auto &fk : table.second.fks)
        {
            table.second.columns[fk.first].fk = &fk.second;
            tables[fk.second.table_name].linksToThisTable.insert(table.first);
        }
    }
}

string Database::printTypes(string &si)
{
    string s;
    s += autogenerated_warning;
    s += "#pragma once\n\n";
    s += "#include \"../Types.h\"\n\n";
    s += "namespace polygon4\n{\n\n";
    s += "namespace detail\n{\n\n";
    s += "enum class EObjectType : int\n";
    s += "{\n";
    for (auto &table : tables)
        s += space + getTableName(table.first) + ",\n";
    s += "};\n\n";
    for (auto &table : tables)
        s += table.second.printForward();
    s += "\n";
    s += "class IObject\n";
    s += inheritQObject();
    s += "{\n";
    s += declareQObject();
    s += space + "virtual ~IObject(){}\n";
    s += "\n";
    s += space + "virtual EObjectType getType() const = 0;\n";
    s += space + "virtual Text getVariableString(int columnId) const = 0;\n";
    s += space + "virtual void setVariableString(int columnId, Text text, Ptr<IObject> ptr = Ptr<IObject>()) = 0;\n";
    s += space + "virtual Text getName() const;\n";
    si += "Text IObject::getName() const\n";
    si += "{\n";
    si += space + "return POLYGON4_NONAME;\n";
    si += "}\n\n";
    s += "#ifdef USE_QT\n";
    s += space + "virtual QTreeWidgetItem *printQtTreeView(QTreeWidgetItem *parent) const = 0;\n";
    s += "#endif\n";
    s += "\n";
    s += space + "bool operator<(const IObject &rhs) const\n";
    s += space + "{\n";
    s += space + space + "return getName() < rhs.getName();\n";
    s += space + "}\n";
    s += "};\n\n";
    for (auto &table : tables)
        s += table.second.print(tables, si);
    s += "}\n\n}\n\n";
    return s;
}

string Database::printStorage()
{
    string s;
    s += autogenerated_warning;
    s += "class Storage\n";
    s += "{\n";
    s += "public:\n";
    for (auto &table : tables)
    {
        string name = toVarName(table.first);
        string container = table.second.hasIdField() ? "CMap" : "CVector";
        s += space + container + "<Ptr<" + getTableName(table.first) + ">> " + name + ";\n";
    }
    s += "\n";
    s += space + "virtual void clear() = 0;\n";
    s += space + "virtual void load(ProgressCallback callback = ProgressCallback()) = 0;\n";
    s += space + "virtual void save(ProgressCallback callback = ProgressCallback()) = 0;\n";
    s += "\n";
    s += "#ifdef USE_QT\n";
    s += space + "virtual void printQtTreeView(QTreeWidgetItem *root) const = 0;\n";
    s += space + "virtual QTreeWidgetItem *addRecord(QTreeWidgetItem *item) = 0;\n";
    s += space + "virtual void deleteRecord(QTreeWidgetItem *item) = 0;\n";
    s += "#endif\n";
    s += "\n";
    s += space + "virtual OrderedObjectMap getOrderedMap(EObjectType type) const = 0;\n";
    s += "\n";
    s += printAddDeleteRecordVirtual();
    s += "};\n\n";
    return s;
}

string Database::printStorageImpl(string &si)
{
    string s;
    s += autogenerated_warning;
    s += "class StorageImpl : public Storage\n";
    s += "{\n";
    s += "#ifdef USE_QT\n";
    s += space + "Q_DECLARE_TR_FUNCTIONS(StorageImpl)\n";
    s += "#endif\n\n";
    s += "private:\n";
    s += space + "Ptr<Database> db;" + "\n";
    s += "\n";
    s += "private:\n";
    for (auto &table : tables)
        s += table.second.printIo(tables, si) + "\n";
    s += "public:\n";
    s += space + "StorageImpl(Ptr<Database> db) : db(db) {}" + "\n";
    s += "\n";

    s += space + "virtual void clear();\n";
    si += "void " + storageImpl + "::clear()\n";
    si += "{\n";
    for (auto &table : tables)
        si += space + toVarName(table.first) + ".clear();\n";
    si += "}\n\n";
    
    double step = 100.0 / (tables.size() * 3.0);
    double progress = 0;
    s += space + "virtual void load(ProgressCallback callback = ProgressCallback());\n";
    si += "void " + storageImpl + "::load(ProgressCallback callback)\n";
    si += "{\n";
    for (auto &table : tables)
    {
        si += space + "_load" + table.first + "();\n";
        si += space + "PROGRESS_CALLBACK(" + to_string(progress += step) + ");\n";
    }
    si += "\n";
    for (auto &table : tables)
    {
        si += space + "_load" + table.first + "Ptrs();\n";
        si += space + "PROGRESS_CALLBACK(" + to_string(progress += step) + ");\n";
    }
    si += "\n";
    for (auto &table : tables)
    {
        si += space + "_load" + table.first + "Arrays();\n";
        si += space + "PROGRESS_CALLBACK(" + to_string(progress += step) + ");\n";
    }
    si += "}\n\n";
    
    step = 100.0 / double(tables.size());
    progress = 0;
    s += space + "virtual void save(ProgressCallback callback = ProgressCallback());\n";
    si += "void " + storageImpl + "::save(ProgressCallback callback)\n";
    si += "{\n";
    auto tbls = mapToSet(tables);
    for (auto &table : tbls)
    {
        si += space + "_save" + table.name + "();\n";
        si += space + "PROGRESS_CALLBACK(" + to_string(progress += step) + ");\n";
    }
    si += "}\n\n";

    s += "\n";
    s += printAddDeleteRecord(si);
    s += "\n";
    si += "\n";

    s += "#ifdef USE_QT\n";
    si += "#ifdef USE_QT\n";
    s += printQtTreeView(si);
    si += "#endif\n\n";
    s += "#endif\n";
    s += printGetOrderedMap(si);
    s += "};\n\n";
    return s;
}

string Database::printAddDeleteRecordVirtual()
{
    string s;
    for (auto &table : tables)
    {
        if (removeFromAddRecord.find(table.first) != removeFromAddRecord.end())
            continue;
        s += space + "virtual Ptr<" + getTableName(table.second.name) + "> add" + getTableName(table.second.name) + "(IObject *parent = 0) = 0;\n";
        s += space + "virtual void delete" + getTableName(table.second.name) + "(" + getTableName(table.second.name) + " *object) = 0;\n";
    }
    s += "\n";
    s += space + "virtual Ptr<IObject> addRecord(IObject *parent = 0) = 0;\n";
    s += space + "virtual void deleteRecord(IObject *data) = 0;\n";
    return s;
}

string Database::printAddDeleteRecord(string &si)
{
    string s;
    for (auto &table : tables)
    {
        if (removeFromAddRecord.find(table.first) != removeFromAddRecord.end())
            continue;
        s += space + "virtual Ptr<" + getTableName(table.second.name) + "> add" + getTableName(table.second.name) + "(IObject *parent = 0);\n";
        si += "Ptr<" + getTableName(table.second.name) + "> " + storageImpl + "::add" + getTableName(table.second.name) + "(IObject *parent)\n";
        si += "{\n";
        if (isMapTable(getTableName(table.first)))
        {
            si += space + "int id = 1;\n";
            si += space + "if (!" + toVarName(table.second.name) + ".empty())" + "\n";
            si += space + ::space + "id = " + toVarName(table.second.name) + ".rbegin()->first + 1;" + "\n";
            si += space + "auto v = std::make_shared<" + getTableName(table.second.name) + ">();" + "\n";
            si += space + "v->id = id;" + "\n";
            si += space + "" + toVarName(table.second.name) + "[v->id] = v;" + "\n";

            string var = toVarName(getParentType(table.first));
            si += space + getParentType(table.first) + " *" + var +
                " = (" + getParentType(table.first) + " *)parent;" + "\n";
            si += space + var + "->" + toVarName(table.first.substr(var.size())) +
                ".push_back(v);" + "\n";
            si += space + "v->" + var + " = " + var + "s[" + var + "->id];" + "\n";

        }
        else
        {
            if (treeViewItems.find(table.second.name) != treeViewItems.end())
            {
                si += space + "int id = 1;\n";
                si += space + "if (!" + toVarName(table.second.name) + ".empty())" + "\n";
                si += space + ::space + "id = " + toVarName(table.second.name) + ".rbegin()->first + 1;" + "\n";
                si += space + "auto v = std::make_shared<" + getTableName(table.second.name) + ">();" + "\n";
                si += space + "v->id = id;" + "\n";
                si += space + "" + toVarName(table.second.name) + "[v->id] = v;" + "\n";
            }
            else
            {
                string var = toVarName(getParentType(table.first));
                si += space + "auto v = std::make_shared<" + getTableName(table.second.name) + ">();" + "\n";
                si += space + getParentType(table.first) + " *" + var +
                    " = (" + getParentType(table.first) + " *)parent;" + "\n";
                si += space + var + "->" + toVarName(table.first.substr(var.size())) +
                    ".push_back(v);" + "\n";
                si += space + toVarName(table.first) + ".push_back(v);" + "\n";
                si += space + "v->" + var + " = " + var + "s[" + var + "->id];" + "\n";
            }
        }
        si += space + "return v;\n";
        si += "}\n\n";

        s += space + "virtual void delete" + getTableName(table.second.name) + "(" + getTableName(table.second.name) + " *object);\n";
        si += "void " + storageImpl + "::delete" + getTableName(table.second.name) + "(" + getTableName(table.second.name) + " *v)\n";
        si += "{\n";
        if (treeViewItems.find(table.second.name) != treeViewItems.end() || isMapTable(getTableName(table.second.name)))
        {
            si += space + "" + toVarName(table.second.name) + ".erase(v->id);" + "\n";
        }
        else
        {
            string var = toVarName(table.second.name);
            si += space + "while (1)\n";
            si += space + "{\n";
            {
                string space = ::space + ::space;
                si += space + "auto i = find_if(" +
                    var + ".begin(), " + var + ".end(), " +
                    "[v](const Ptr<" + getTableName(table.second.name) + "> &p)" +
                    "{ return p.get() == v; });" + "\n";
                si += space + "if (i == " + var + ".end())\n";
                si += space + ::space + "break;\n";
                si += space + var + ".erase(i);\n";
            }
            si += space + "}\n";
        }
        si += "}\n\n";
    }
    s += "\n";

    s += space + "virtual Ptr<IObject> addRecord(IObject *parent = 0);\n";
    si += "Ptr<IObject> " + storageImpl + "::addRecord(IObject *parent)\n";
    si += "{\n";
    si += space + "EObjectType type = parent->getType();\n";
    si += space + "switch (type)\n";
    si += space + "{\n";
    for (auto &table : tables)
    {
        if (removeFromAddRecord.find(table.first) != removeFromAddRecord.end())
            continue;
        si += ::space + "case EObjectType::" + getTableName(table.second.name) + ":" + "\n";
        si += space + space + "return add" + getTableName(table.second.name) + "(parent);" + "\n";

    }
    si += space + "default:" + "\n";
    si += space + space + "return Ptr<IObject>(0);\n";
    si += space + "}\n";
    si += "}\n\n";

    s += space + "virtual void deleteRecord(IObject *data);\n";
    si += "void " + storageImpl + "::deleteRecord(IObject *data)\n";
    si += "{\n";
    si += space + "EObjectType type = data->getType();\n";
    si += space + "switch (type)\n";
    si += space + "{\n";
    for (auto &table : tables)
    {
        if (removeFromAddRecord.find(table.first) != removeFromAddRecord.end())
            continue;

        string space = ::space + ::space;
        si += ::space + "case EObjectType::" + getTableName(table.second.name) + ":" + "\n";
        si += space + "delete" + getTableName(table.second.name) + "((" + getTableName(table.second.name) + " *)data);" + "\n";
        si += space + "break;\n";
    }
    si += space + "default:" + "\n";
    si += space + space + "break;\n";
    si += space + "}\n";
    si += "}\n";
    return s;
}

string Database::printQtTreeView(string &si)
{
    string s;

    s += space + "virtual void printQtTreeView(QTreeWidgetItem *root) const;\n";
    si += "void " + storageImpl + "::printQtTreeView(QTreeWidgetItem *root) const\n";
    si += "{\n";
    si += space + "QTreeWidgetItem *item;\n";
    for (auto &table : tables)
    {
        if (treeViewItems.find(table.second.name) == treeViewItems.end())
            continue;

        si += "\n";
        si += space + "item = new QTreeWidgetItem(root, QStringList(" + tr(splitWords(table.second.name)) + "));" + "\n";
        si += space + "item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::" + getTableName(table.second.name) + "));" + "\n";
        si += space + "auto " + toVarName(table.second.name) + " = getOrderedMap(EObjectType::" + getTableName(table.second.name) + ");\n";
        si += space + "for (auto &" + getTableName(toVarName(table.second.name)) + " : " + toVarName(table.second.name) + ")\n";
        si += space + space + getTableName(toVarName(table.second.name)) + ".second->printQtTreeView(item);" + "\n";
    }
    si += "}\n\n";

    s += space + "virtual QTreeWidgetItem *addRecord(QTreeWidgetItem *item);\n";
    si += "QTreeWidgetItem *" + storageImpl + "::addRecord(QTreeWidgetItem *item)\n";
    si += "{\n";
    si += space + "EObjectType type = static_cast<EObjectType>(item->data(0, Qt::UserRole).toInt());\n";
    si += space + "IObject *parent = 0;" + "\n";
    si += space + "auto parentItem = item->parent();" + "\n";
    si += space + "if (parentItem)" + "\n";
    si += space + space + "parent = (IObject *)parentItem->data(0, Qt::UserRole).toULongLong();" + "\n";
    si += space + "switch (type)\n";
    si += space + "{\n";
    for (auto &table : tables)
    {
        if (removeFromAddRecord.find(table.first) != removeFromAddRecord.end())
            continue;

        si += ::space + "case EObjectType::" + getTableName(table.second.name) + ":" + "\n";
        string space = ::space + ::space;
        si += space + "return add" + getTableName(table.second.name) + "(parent)->printQtTreeView(item);" + "\n";
    }
    si += space + "default:" + "\n";
    si += space + space + "return 0;\n";
    si += space + "}\n";
    si += "}\n\n";

    s += space + "virtual void deleteRecord(QTreeWidgetItem *item);\n";
    si += "void " + storageImpl + "::deleteRecord(QTreeWidgetItem *item)\n";
    si += "{\n";
    si += space + "IObject *data = (IObject *)item->data(0, Qt::UserRole).toULongLong(); " + "\n";
    si += space + "EObjectType type = data->getType();\n";
    si += space + "switch (type)\n";
    si += space + "{\n";
    for (auto &table : tables)
    {
        if (removeFromAddRecord.find(table.first) != removeFromAddRecord.end())
            continue;
        
        string space = ::space + ::space;
        si += ::space + "case EObjectType::" + getTableName(table.second.name) + ":" + "\n";
        si += space + "delete" + getTableName(table.second.name) + "((" + getTableName(table.second.name) + " *)data);" + "\n";
        si += space + "break;\n";
    }
    si += space + "default:" + "\n";
    si += space + space + "break;\n";
    si += space + "}\n";
    si += space + "item->parent()->removeChild(item);" + "\n";
    si += "}\n";

    return s;
}

string Database::printTypesUsing()
{
    string s;
    s += autogenerated_warning;
    for (auto &table : tables)
        s += table.second.printUsing();
    return s;
}

string Database::printHelpers(string &si)
{
    string s;
    s += autogenerated_warning;
    si += autogenerated_warning;
    
    s += "EObjectType getTableType(const std::string &table);\n";
    si += "EObjectType getTableType(const std::string &table)\n";
    si += "{\n";
    si += space + "static std::map<std::string, EObjectType> types =\n";
    si += space + "{\n";
    {
        string space = ::space + ::space;
        for (auto &table : tables)
            si += space + "{ \"" + table.first + "\", EObjectType::" + getTableName(table.first) + " },\n";
    }
    si += space + "};\n";
    si += space + "return types[table];\n";
    si += "};\n\n";
    
    s += "std::string getTableNameByType(EObjectType type);\n";
    si += "std::string getTableNameByType(EObjectType type)\n";
    si += "{\n";
    si += space + "static std::map<EObjectType, std::string> tables =\n";
    si += space + "{\n";
    {
        string space = ::space + ::space;
        for (auto &table : tables)
            si += space + "{ EObjectType::" + getTableName(table.first) + ", \"" + table.first + "\" },\n";
    }
    si += space + "};\n";
    si += space + "return tables[type];\n";
    si += "};\n\n";
    
    s += "#ifdef USE_QT\n";
    si += "#ifdef USE_QT\n";

    set<string> fields;
    for (auto &table : tables)
        for (auto &col : table.second.columns)
            fields.insert(col.second.name);

    s += "void retranslateFieldNames();\n";
    si += "typedef std::map<std::string, QString> FieldNames;\n\n";
    si += "FieldNames fieldNames;\n\n";
    si += "void retranslateFieldNames()\n";
    si += "{\n";
    si += space + "FieldNames names =\n";
    si += space + "{\n";
    {
        string space = ::space + ::space;
        for (auto &f : fields)
            si += space + "{ \"" + f + "\", " + tr(f) + " },\n";
    }
    si += space + "};\n";
    si += space + "fieldNames = names;\n";
    si += "};\n\n";

    s += "QString getFieldName(const std::string &name);\n";
    si += "QString getFieldName(const std::string &name)\n";
    si += "{\n";
    si += space + "return fieldNames[name];\n";
    si += "};\n";

    s += "#endif\n";
    si += "#endif\n";

    return s;
}

string Database::printGetOrderedMap(string &si)
{
    string s;
    s += space + "virtual OrderedObjectMap getOrderedMap(EObjectType type) const;\n";
    si += "OrderedObjectMap " + storageImpl + "::getOrderedMap(EObjectType type) const\n";
    si += "{\n";
    si += space + "switch (type)\n";
    si += space + "{\n";
    for (auto &table : tables)
    {
        string space = ::space + ::space;
        si += ::space + "case EObjectType::" + getTableName(table.second.name) + ":" + "\n";
        si += space + "return ::getOrderedMap(" + toVarName(table.second.name) + ");\n";
    }
    si += space + "default:" + "\n";
    si += space + space + "return OrderedObjectMap();\n";
    si += space + "}\n";
    si += "}\n";
    return s;
}

string Database::printPy()
{
    string s;
    s += "#!/usr/bin/python3\n";
    s += "# -*- coding: utf-8 -*-\n\n";
    s += "tables = [\n";
    for (auto &table : tables)
    {
        s += space + "'" + toVarName(table.first) + "'" + ",\n";
    }
    s += "]\n";
    return s;
}
